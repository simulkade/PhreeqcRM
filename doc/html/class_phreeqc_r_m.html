<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PhreeqcRM: PhreeqcRM C++ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PhreeqcRM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="class_phreeqc_r_m.html"><span>C++&#160;Documentation</span></a></li>
      <li><a href="_r_m__interface___c_8h.html"><span>C&#160;Documentation</span></a></li>
      <li><a href="classphreeqcrm.html"><span>Fortran&#160;Documentation</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PhreeqcRM C++ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf01f0b9ab2101d9b073c205804b255e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM</a> (int nxyz, int thread_count_or_communicator, PHRQ_io *io=NULL)</td></tr>
<tr class="separator:adf01f0b9ab2101d9b073c205804b255e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9eb39e299d0d44388367dd27900996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#abf9eb39e299d0d44388367dd27900996">CloseFiles</a> (void)</td></tr>
<tr class="separator:abf9eb39e299d0d44388367dd27900996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91d035f4839205de54a34a0d62cf9e8"><td class="memItemLeft" align="right" valign="top">IPhreeqc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af91d035f4839205de54a34a0d62cf9e8">Concentrations2Utility</a> (std::vector&lt; double &gt; &amp;c, std::vector&lt; double &gt; tc, std::vector&lt; double &gt; p_atm)</td></tr>
<tr class="separator:af91d035f4839205de54a34a0d62cf9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5f01e00ec7e9de4ab0f06a3c16e31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a> (std::vector&lt; int &gt; &amp;grid2chem)</td></tr>
<tr class="separator:a6e5f01e00ec7e9de4ab0f06a3c16e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac0574257be4e62ad314f61a1d9f015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a> (int result)</td></tr>
<tr class="separator:a0ac0574257be4e62ad314f61a1d9f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc339ef18879fc6747c7cb3ee8b407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a69bc339ef18879fc6747c7cb3ee8b407">DumpModule</a> (bool dump_on, bool append=false)</td></tr>
<tr class="separator:a69bc339ef18879fc6747c7cb3ee8b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb864f4e9d7814f505ded458cb7fc01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#acb864f4e9d7814f505ded458cb7fc01b">ErrorHandler</a> (int result, const std::string &amp;e_string)</td></tr>
<tr class="separator:acb864f4e9d7814f505ded458cb7fc01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62514bca8a5119822e58a75db087cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a> (const std::string &amp;error_string, bool prepend=true)</td></tr>
<tr class="separator:ad62514bca8a5119822e58a75db087cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292c626fe8a387d1144e139722ab43e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> ()</td></tr>
<tr class="separator:ab292c626fe8a387d1144e139722ab43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18e1842d69e819df1737a08f4190c33"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector<br class="typebreak" />
&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ac18e1842d69e819df1737a08f4190c33">GetBackwardMapping</a> (void)</td></tr>
<tr class="separator:ac18e1842d69e819df1737a08f4190c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47b5eee0491908654645ebb899ecb63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad47b5eee0491908654645ebb899ecb63">GetChemistryCellCount</a> (void) const </td></tr>
<tr class="separator:ad47b5eee0491908654645ebb899ecb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ac2b0172e9aa11f3537c74d4e1aa7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a> (void) const </td></tr>
<tr class="separator:a25ac2b0172e9aa11f3537c74d4e1aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a63b9d464b9b91e1a18efdcf9900c7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a59a63b9d464b9b91e1a18efdcf9900c7">GetComponents</a> (void) const </td></tr>
<tr class="separator:a59a63b9d464b9b91e1a18efdcf9900c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48d2ebd2e0efed5c49431c191159462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a> (std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="separator:aa48d2ebd2e0efed5c49431c191159462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac821fe10814851b2355c32d71bf0e43a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ac821fe10814851b2355c32d71bf0e43a">GetDatabaseFileName</a> (void)</td></tr>
<tr class="separator:ac821fe10814851b2355c32d71bf0e43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1890077c451ea8864e441dbf4bd45a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a1890077c451ea8864e441dbf4bd45a8d">GetDensity</a> (std::vector&lt; double &gt; &amp;density)</td></tr>
<tr class="separator:a1890077c451ea8864e441dbf4bd45a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ef701a669817c88287cfe2a24fe21"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#acc4ef701a669817c88287cfe2a24fe21">GetEndCell</a> (void) const </td></tr>
<tr class="separator:acc4ef701a669817c88287cfe2a24fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab675139c6a769304ef5acf795febbbf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aab675139c6a769304ef5acf795febbbf">GetEquilibriumPhases</a> (void) const </td></tr>
<tr class="separator:aab675139c6a769304ef5acf795febbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aadf145d1edd3a38213290608e903c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a17aadf145d1edd3a38213290608e903c">GetEquilibriumPhasesCount</a> (void) const </td></tr>
<tr class="separator:a17aadf145d1edd3a38213290608e903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af657da23ae5a2bfbde593c4f05d69e6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af657da23ae5a2bfbde593c4f05d69e6c">GetErrorHandlerMode</a> (void)</td></tr>
<tr class="separator:af657da23ae5a2bfbde593c4f05d69e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0769fc515bc2738ce991d4e81ded7fae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a0769fc515bc2738ce991d4e81ded7fae">GetErrorString</a> (void)</td></tr>
<tr class="separator:a0769fc515bc2738ce991d4e81ded7fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fd5597312c707f29369e0a74824311"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a54fd5597312c707f29369e0a74824311">GetExchangeNames</a> (void) const </td></tr>
<tr class="separator:a54fd5597312c707f29369e0a74824311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ef60da8a54fcabf0aa88ba4cf0686"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3d4ef60da8a54fcabf0aa88ba4cf0686">GetExchangeSpecies</a> (void) const </td></tr>
<tr class="separator:a3d4ef60da8a54fcabf0aa88ba4cf0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38e24e1cb590d34fd97f395ff8506ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af38e24e1cb590d34fd97f395ff8506ba">GetExchangeSpeciesCount</a> (void) const </td></tr>
<tr class="separator:af38e24e1cb590d34fd97f395ff8506ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097034fe3815caf183fb2635a8559c91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a097034fe3815caf183fb2635a8559c91">GetFilePrefix</a> (void)</td></tr>
<tr class="separator:a097034fe3815caf183fb2635a8559c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0baa43d30518ec4fb20872213a6663"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a1e0baa43d30518ec4fb20872213a6663">GetForwardMapping</a> (void)</td></tr>
<tr class="separator:a1e0baa43d30518ec4fb20872213a6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324da78ebfd28319bb7545a0132e4361"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a324da78ebfd28319bb7545a0132e4361">GetGasComponents</a> (void) const </td></tr>
<tr class="separator:a324da78ebfd28319bb7545a0132e4361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa8e74a7b7454c14755f017c778c62d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7aa8e74a7b7454c14755f017c778c62d">GetGasComponentsCount</a> (void) const </td></tr>
<tr class="separator:a7aa8e74a7b7454c14755f017c778c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83619a4a93f185ebd427f10c5b41306"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ab83619a4a93f185ebd427f10c5b41306">GetGfw</a> (void)</td></tr>
<tr class="separator:ab83619a4a93f185ebd427f10c5b41306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0a9fa184dd8c8568b74cd5c10091c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a> (void)</td></tr>
<tr class="separator:a3e0a9fa184dd8c8568b74cd5c10091c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac492b8e6e7d0380ec37ff283dd08f2c2"><td class="memItemLeft" align="right" valign="top">IPhreeqc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ac492b8e6e7d0380ec37ff283dd08f2c2">GetIPhreeqcPointer</a> (int i)</td></tr>
<tr class="separator:ac492b8e6e7d0380ec37ff283dd08f2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355346f344d47b43bfb55815e9ac0f6e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a355346f344d47b43bfb55815e9ac0f6e">GetKineticReactions</a> (void) const </td></tr>
<tr class="separator:a355346f344d47b43bfb55815e9ac0f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50317758e3ac3152ae60cf8f8d6efe0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa50317758e3ac3152ae60cf8f8d6efe0">GetKineticReactionsCount</a> (void) const </td></tr>
<tr class="separator:aa50317758e3ac3152ae60cf8f8d6efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6435a77f5409c10ebfd8c70cb6a309"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a5b6435a77f5409c10ebfd8c70cb6a309">GetMpiMyself</a> (void) const </td></tr>
<tr class="separator:a5b6435a77f5409c10ebfd8c70cb6a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767aba1bbc547eec71cb0067854b8a9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a> (void) const </td></tr>
<tr class="separator:a767aba1bbc547eec71cb0067854b8a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eb8523bff2a58b0ba1c3835f5ffb92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a> (int n)</td></tr>
<tr class="separator:af7eb8523bff2a58b0ba1c3835f5ffb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bd52b5380331c67d47960bb096f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a730bd52b5380331c67d47960bb096f00">GetPartitionUZSolids</a> (void) const </td></tr>
<tr class="separator:a730bd52b5380331c67d47960bb096f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af783c5401d3f2758fb65e0fb88fd9ffe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af783c5401d3f2758fb65e0fb88fd9ffe">GetPressure</a> (void)</td></tr>
<tr class="separator:af783c5401d3f2758fb65e0fb88fd9ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb0082dd5d1d4f04e0fb53f08c354ef"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3fb0082dd5d1d4f04e0fb53f08c354ef">GetPrintChemistryMask</a> (void)</td></tr>
<tr class="separator:a3fb0082dd5d1d4f04e0fb53f08c354ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95608dd9d130371e5373b58629beadc9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a95608dd9d130371e5373b58629beadc9">GetPrintChemistryOn</a> (void) const </td></tr>
<tr class="separator:a95608dd9d130371e5373b58629beadc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e44060d9acad18e13a2acc5a589b9d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a9e44060d9acad18e13a2acc5a589b9d5">GetRebalanceByCell</a> (void) const </td></tr>
<tr class="separator:a9e44060d9acad18e13a2acc5a589b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899c14198741359c3405507ea6022879"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a899c14198741359c3405507ea6022879">GetRebalanceFraction</a> (void) const </td></tr>
<tr class="separator:a899c14198741359c3405507ea6022879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0258eb0b928fc2eabdc0b4a07f064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a> (std::vector&lt; double &gt; &amp;sat)</td></tr>
<tr class="separator:a25a0258eb0b928fc2eabdc0b4a07f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6179a2e85f8d5ac45174c097ac585dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a> (std::vector&lt; double &gt; &amp;so)</td></tr>
<tr class="separator:a6179a2e85f8d5ac45174c097ac585dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af386ce0d85cd88eaf13ef75d8f891901"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a> (void)</td></tr>
<tr class="separator:af386ce0d85cd88eaf13ef75d8f891901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31d2f31f4b64d01fdd0c0cddb471d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a> (void)</td></tr>
<tr class="separator:ad31d2f31f4b64d01fdd0c0cddb471d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd1de7f3b7511b1a789e2f0f1ed897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a> (int icol, std::string &amp;heading)</td></tr>
<tr class="separator:a8dfd1de7f3b7511b1a789e2f0f1ed897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4de1533d505faf5b5b3f913d9c6246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a2b4de1533d505faf5b5b3f913d9c6246">GetSelectedOutputOn</a> (void)</td></tr>
<tr class="separator:a2b4de1533d505faf5b5b3f913d9c6246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6534199611b9dc7d7dc15e33da58fb7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a> (void)</td></tr>
<tr class="separator:a6534199611b9dc7d7dc15e33da58fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf5f318493ca94de71fbf839910f379"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7bf5f318493ca94de71fbf839910f379">GetSICount</a> (void) const </td></tr>
<tr class="separator:a7bf5f318493ca94de71fbf839910f379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f47533d63d2df6972acbbfef7d5e037"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a9f47533d63d2df6972acbbfef7d5e037">GetSINames</a> (void) const </td></tr>
<tr class="separator:a9f47533d63d2df6972acbbfef7d5e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdf4e16dd8c17839ea4e26ad2e0711b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#afbdf4e16dd8c17839ea4e26ad2e0711b">GetSolidSolutionComponents</a> (void) const </td></tr>
<tr class="separator:afbdf4e16dd8c17839ea4e26ad2e0711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69ecfcf73c2ca674b4a02377bc58e1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa69ecfcf73c2ca674b4a02377bc58e1f">GetSolidSolutionComponentsCount</a> (void) const </td></tr>
<tr class="separator:aa69ecfcf73c2ca674b4a02377bc58e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f694b09fa03c7c120d5333ee05d4f8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a20f694b09fa03c7c120d5333ee05d4f8">GetSolidSolutionNames</a> (void) const </td></tr>
<tr class="separator:a20f694b09fa03c7c120d5333ee05d4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98170e44d8269da4bde0c42f2ab4e75"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a> (void)</td></tr>
<tr class="separator:ae98170e44d8269da4bde0c42f2ab4e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1f8e12c41d225c06226d07ba181486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a> (std::vector&lt; double &gt; &amp;species_conc)</td></tr>
<tr class="separator:aef1f8e12c41d225c06226d07ba181486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ef74307edc3107819375525e7b286"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a> (void)</td></tr>
<tr class="separator:a997ef74307edc3107819375525e7b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8af1412943fa2f99968827cf53ab42"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a> (void)</td></tr>
<tr class="separator:aed8af1412943fa2f99968827cf53ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e62ada4632f1fe2f75205cdcf8df60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a> (std::vector&lt; double &gt; &amp;species_log10gammas)</td></tr>
<tr class="separator:a46e62ada4632f1fe2f75205cdcf8df60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbece4a9759d711ef68684f9d895ad"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a> (void)</td></tr>
<tr class="separator:adcdbece4a9759d711ef68684f9d895ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef7ac666c8bf48409d17d898f6a9041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a> (void)</td></tr>
<tr class="separator:aaef7ac666c8bf48409d17d898f6a9041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85cfc68368c1ec30a6318397dd57daa"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak" />
&lt; cxxNameDouble &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a> (void)</td></tr>
<tr class="separator:aa85cfc68368c1ec30a6318397dd57daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2003caaa23e9039372b774ea98e874cb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a> (void)</td></tr>
<tr class="separator:a2003caaa23e9039372b774ea98e874cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7b8935b7c6837a172503950e1f1e92"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aab7b8935b7c6837a172503950e1f1e92">GetStartCell</a> (void) const </td></tr>
<tr class="separator:aab7b8935b7c6837a172503950e1f1e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c336bc613c4794a5a5ded1adb2cd7ee"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a> (void) const </td></tr>
<tr class="separator:a7c336bc613c4794a5a5ded1adb2cd7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae082dbed24f997b815194cb03d0d407c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a> (void) const </td></tr>
<tr class="separator:ae082dbed24f997b815194cb03d0d407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2466626f87a4756601db252bb25337"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a> (void) const </td></tr>
<tr class="separator:a2c2466626f87a4756601db252bb25337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b114af9c932a1eafcd16a2e60b3cb9a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a> (void) const </td></tr>
<tr class="separator:a5b114af9c932a1eafcd16a2e60b3cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b63a1e849bd0b56189deca5b434a4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a296b63a1e849bd0b56189deca5b434a4">GetTemperature</a> (void)</td></tr>
<tr class="separator:a296b63a1e849bd0b56189deca5b434a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9b321354b98cfde021c1dbcdd1a321"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a> ()</td></tr>
<tr class="separator:aed9b321354b98cfde021c1dbcdd1a321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee6230be86953d7bbf32319dcbed8fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aeee6230be86953d7bbf32319dcbed8fb">GetTime</a> (void) const </td></tr>
<tr class="separator:aeee6230be86953d7bbf32319dcbed8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b64a9231c9758dd5c38074de0bebeb7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7b64a9231c9758dd5c38074de0bebeb7">GetTimeConversion</a> (void)</td></tr>
<tr class="separator:a7b64a9231c9758dd5c38074de0bebeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8df589c2719c9f8070bdf547398602f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ab8df589c2719c9f8070bdf547398602f">GetTimeStep</a> (void)</td></tr>
<tr class="separator:ab8df589c2719c9f8070bdf547398602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c88809873ff087a08029b3f70ee440"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a79c88809873ff087a08029b3f70ee440">GetUnitsExchange</a> (void)</td></tr>
<tr class="separator:a79c88809873ff087a08029b3f70ee440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f6a5b5ef016fe3d39da5803db15c2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a94f6a5b5ef016fe3d39da5803db15c2a">GetUnitsGasPhase</a> (void)</td></tr>
<tr class="separator:a94f6a5b5ef016fe3d39da5803db15c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459b3b7e889175cd6921bee0a6925c56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a459b3b7e889175cd6921bee0a6925c56">GetUnitsKinetics</a> (void)</td></tr>
<tr class="separator:a459b3b7e889175cd6921bee0a6925c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e5cc05ee11681e3e94d8e97f6e6665"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a85e5cc05ee11681e3e94d8e97f6e6665">GetUnitsPPassemblage</a> (void)</td></tr>
<tr class="separator:a85e5cc05ee11681e3e94d8e97f6e6665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e89c81bcaf299b19f419ae30d02d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a988e89c81bcaf299b19f419ae30d02d8">GetUnitsSolution</a> (void)</td></tr>
<tr class="separator:a988e89c81bcaf299b19f419ae30d02d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee53757d11bc48cddcde12ee2c72f8b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aee53757d11bc48cddcde12ee2c72f8b9">GetUnitsSSassemblage</a> (void)</td></tr>
<tr class="separator:aee53757d11bc48cddcde12ee2c72f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0b7e64493556c8e844e7c6f3a0a227"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7c0b7e64493556c8e844e7c6f3a0a227">GetUnitsSurface</a> (void)</td></tr>
<tr class="separator:a7c0b7e64493556c8e844e7c6f3a0a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc2f010956bab031ecb51024ac82687"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak" />
&lt; IPhreeqcPhast * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3bc2f010956bab031ecb51024ac82687">GetWorkers</a> ()</td></tr>
<tr class="separator:a3bc2f010956bab031ecb51024ac82687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9e308a4cb39cc3a29cfdebd5db263d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aef9e308a4cb39cc3a29cfdebd5db263d">InitialPhreeqc2Concentrations</a> (std::vector&lt; double &gt; &amp;destination_c, std::vector&lt; int &gt; &amp;boundary_solution1)</td></tr>
<tr class="separator:aef9e308a4cb39cc3a29cfdebd5db263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d8b4470a9d6b6c9e41a5e87d971f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad8d8b4470a9d6b6c9e41a5e87d971f48">InitialPhreeqc2Concentrations</a> (std::vector&lt; double &gt; &amp;destination_c, std::vector&lt; int &gt; &amp;boundary_solution1, std::vector&lt; int &gt; &amp;boundary_solution2, std::vector&lt; double &gt; &amp;fraction1)</td></tr>
<tr class="separator:ad8d8b4470a9d6b6c9e41a5e87d971f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8534dbf786f708df79065e3329defc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a> (std::vector&lt; int &gt; &amp;initial_conditions1)</td></tr>
<tr class="separator:acd8534dbf786f708df79065e3329defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a995bd031543a11c745a19af12fcbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a51a995bd031543a11c745a19af12fcbf">InitialPhreeqc2Module</a> (std::vector&lt; int &gt; &amp;initial_conditions1, std::vector&lt; int &gt; &amp;initial_conditions2, std::vector&lt; double &gt; &amp;fraction1)</td></tr>
<tr class="separator:a51a995bd031543a11c745a19af12fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4300a3ba8987c8093d8ca88835667a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa4300a3ba8987c8093d8ca88835667a9">InitialPhreeqc2SpeciesConcentrations</a> (std::vector&lt; double &gt; &amp;destination_c, std::vector&lt; int &gt; &amp;boundary_solution1)</td></tr>
<tr class="separator:aa4300a3ba8987c8093d8ca88835667a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb319053abc6a7be2f93f4801866027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#adbb319053abc6a7be2f93f4801866027">InitialPhreeqc2SpeciesConcentrations</a> (std::vector&lt; double &gt; &amp;destination_c, std::vector&lt; int &gt; &amp;boundary_solution1, std::vector&lt; int &gt; &amp;boundary_solution2, std::vector&lt; double &gt; &amp;fraction1)</td></tr>
<tr class="separator:adbb319053abc6a7be2f93f4801866027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8c258616d470bde73c490bd97ccf4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a> (int n, const std::vector&lt; int &gt; &amp;cell_numbers)</td></tr>
<tr class="separator:adf8c258616d470bde73c490bd97ccf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471917c3a3b72d32a3aff2277c846ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a471917c3a3b72d32a3aff2277c846ce4">LoadDatabase</a> (const std::string &amp;database)</td></tr>
<tr class="separator:a471917c3a3b72d32a3aff2277c846ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb0eec0cbbd282137f9e699fc7136ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a> (const std::string &amp;str)</td></tr>
<tr class="separator:aefb0eec0cbbd282137f9e699fc7136ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc27edb51d5c1b01042bc445a8950c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa7bc27edb51d5c1b01042bc445a8950c">MpiAbort</a> ()</td></tr>
<tr class="separator:aa7bc27edb51d5c1b01042bc445a8950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386912253775a48a7c27c653f85ae867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> ()</td></tr>
<tr class="separator:a386912253775a48a7c27c653f85ae867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480f76aef4f930795c95ee93c6da51a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a> ()</td></tr>
<tr class="separator:a480f76aef4f930795c95ee93c6da51a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64697f92b2323655ae7593fe2a35cb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a> (void)</td></tr>
<tr class="separator:a64697f92b2323655ae7593fe2a35cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380cc59e9ee851d0493f6ee795b4c205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a380cc59e9ee851d0493f6ee795b4c205">OutputMessage</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a380cc59e9ee851d0493f6ee795b4c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b3bf039921645f512d447d3fc6b34b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> (void)</td></tr>
<tr class="separator:ac0b3bf039921645f512d447d3fc6b34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36deedf92cfa74f46317e8cbd8843ca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a36deedf92cfa74f46317e8cbd8843ca1">ReturnHandler</a> (<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> result, const std::string &amp;e_string)</td></tr>
<tr class="separator:a36deedf92cfa74f46317e8cbd8843ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f1310be884080f16ff62597ae56455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a> (bool workers, bool initial_phreeqc, bool utility, const std::string &amp;chemistry_name)</td></tr>
<tr class="separator:aa1f1310be884080f16ff62597ae56455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4b46db5b1b600a6f8ce4522a27d955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a> (bool workers, bool initial_phreeqc, bool utility, const std::string &amp;input_string)</td></tr>
<tr class="separator:a1e4b46db5b1b600a6f8ce4522a27d955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0462b92c2a5aa473af73ba3a54cd27e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a0462b92c2a5aa473af73ba3a54cd27e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e9d1d88b23b5da1dad1eb35e415b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad61e9d1d88b23b5da1dad1eb35e415b1">SetComponentH2O</a> (bool tf)</td></tr>
<tr class="separator:ad61e9d1d88b23b5da1dad1eb35e415b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c61949ecec49665d4c6ae2ccd040159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a> (const std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="separator:a7c61949ecec49665d4c6ae2ccd040159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093a4d3c160ef5aa7cd65cf29b084268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> (int n_user)</td></tr>
<tr class="separator:a093a4d3c160ef5aa7cd65cf29b084268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc453d9dbfef8223bb289900ac5d404d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a> (const std::vector&lt; double &gt; &amp;density)</td></tr>
<tr class="separator:abc453d9dbfef8223bb289900ac5d404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d70b6e7cf9071181291bdcab7603a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a6d70b6e7cf9071181291bdcab7603a9c">SetDumpFileName</a> (const std::string &amp;dump_name)</td></tr>
<tr class="separator:a6d70b6e7cf9071181291bdcab7603a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c01d10280887c3ace8e0fbe179baa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a06c01d10280887c3ace8e0fbe179baa2">SetErrorHandlerMode</a> (int mode)</td></tr>
<tr class="separator:a06c01d10280887c3ace8e0fbe179baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7054027113b3f4128b2f02fa07fafac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:ae7054027113b3f4128b2f02fa07fafac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0bf250a5b462cb5d88b49cd98f5cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a> (int(*fcn)(int *method, void *cookie))</td></tr>
<tr class="separator:a82f0bf250a5b462cb5d88b49cd98f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92c97628615d7209259522662860a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a> (void *cookie)</td></tr>
<tr class="separator:ad92c97628615d7209259522662860a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a60735d2ea38e0a31fb3cc05684881a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a5a60735d2ea38e0a31fb3cc05684881a">SetMpiWorkerCallbackFortran</a> (int(*fcn)(int *method))</td></tr>
<tr class="separator:a5a60735d2ea38e0a31fb3cc05684881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999cacdcaddc4b9c20b7a00ee7ea9f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a999cacdcaddc4b9c20b7a00ee7ea9f0b">SetPartitionUZSolids</a> (bool tf)</td></tr>
<tr class="separator:a999cacdcaddc4b9c20b7a00ee7ea9f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe5d536517af8694debc756b504f4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a> (const std::vector&lt; double &gt; &amp;por)</td></tr>
<tr class="separator:aabe5d536517af8694debc756b504f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baced65c80a9466af317faaab9ad7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a> (const std::vector&lt; double &gt; &amp;p)</td></tr>
<tr class="separator:a9baced65c80a9466af317faaab9ad7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b2dff739ed070378aa8a3584a5399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a> (std::vector&lt; int &gt; &amp;cell_mask)</td></tr>
<tr class="separator:a4b4b2dff739ed070378aa8a3584a5399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad390b50790a370bba13b02318355b3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a> (bool workers, bool initial_phreeqc, bool utility)</td></tr>
<tr class="separator:ad390b50790a370bba13b02318355b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2b742b0e4b9d8ba180202ca9ee438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a41f2b742b0e4b9d8ba180202ca9ee438">SetRebalanceByCell</a> (bool tf)</td></tr>
<tr class="separator:a41f2b742b0e4b9d8ba180202ca9ee438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136d9ac45da1ab013f5d9f7236d55850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a136d9ac45da1ab013f5d9f7236d55850">SetRebalanceFraction</a> (double f)</td></tr>
<tr class="separator:a136d9ac45da1ab013f5d9f7236d55850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738d57a411bdef1f08d3b8ec66e2f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a> (const std::vector&lt; double &gt; &amp;rv)</td></tr>
<tr class="separator:a3738d57a411bdef1f08d3b8ec66e2f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191e1e4a66362bd2e1e5e6b26acfcc95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a> (const std::vector&lt; double &gt; &amp;sat)</td></tr>
<tr class="separator:a191e1e4a66362bd2e1e5e6b26acfcc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c25a7dd33870fb20efe9d7d367386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a1a9c25a7dd33870fb20efe9d7d367386">SetScreenOn</a> (bool tf)</td></tr>
<tr class="separator:a1a9c25a7dd33870fb20efe9d7d367386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8321dd429fbfa0c7b84754aae63d8d88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a> (bool tf)</td></tr>
<tr class="separator:a8321dd429fbfa0c7b84754aae63d8d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf105c074d5735433178e941c7a609e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> (bool save_on)</td></tr>
<tr class="separator:acf105c074d5735433178e941c7a609e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b62c3f80f6be11ba952b92b315441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a> (const std::vector&lt; double &gt; &amp;t)</td></tr>
<tr class="separator:a725b62c3f80f6be11ba952b92b315441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a058be326aa249c25316b0cbac05e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a> (double time)</td></tr>
<tr class="separator:a81a058be326aa249c25316b0cbac05e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7abc26d7a64299d4fa1b879a00c364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a> (double conv_factor)</td></tr>
<tr class="separator:a5b7abc26d7a64299d4fa1b879a00c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261cac78c338a2ef92b2b548e2c017ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a> (double time_step)</td></tr>
<tr class="separator:a261cac78c338a2ef92b2b548e2c017ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493bd0929d290210735ee6e7d3e313c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a493bd0929d290210735ee6e7d3e313c9">SetUnitsExchange</a> (int option)</td></tr>
<tr class="separator:a493bd0929d290210735ee6e7d3e313c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb91663bccb79a4bd44c2cea4e4bae2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#acb91663bccb79a4bd44c2cea4e4bae2f">SetUnitsGasPhase</a> (int option)</td></tr>
<tr class="separator:acb91663bccb79a4bd44c2cea4e4bae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62278fa7e20047a358dcad3dffa7b6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a62278fa7e20047a358dcad3dffa7b6ba">SetUnitsKinetics</a> (int option)</td></tr>
<tr class="separator:a62278fa7e20047a358dcad3dffa7b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f501e1e26008b85e169123ad458a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a553f501e1e26008b85e169123ad458a5">SetUnitsPPassemblage</a> (int option)</td></tr>
<tr class="separator:a553f501e1e26008b85e169123ad458a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b22ee262f00a1186c4455098315ba07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a> (int option)</td></tr>
<tr class="separator:a3b22ee262f00a1186c4455098315ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b445479212a6f9dc3455ecdb40a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a579b445479212a6f9dc3455ecdb40a20">SetUnitsSSassemblage</a> (int option)</td></tr>
<tr class="separator:a579b445479212a6f9dc3455ecdb40a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578f4b12f58165e57381ceddffba8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a0578f4b12f58165e57381ceddffba8d9">SetUnitsSurface</a> (int option)</td></tr>
<tr class="separator:a0578f4b12f58165e57381ceddffba8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35039947fade6a9f3e94fe0654ea5ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a> (std::vector&lt; double &gt; &amp;species_conc)</td></tr>
<tr class="separator:a35039947fade6a9f3e94fe0654ea5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df19c6fe5d51d6e8e45c5bbf8ad0712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a> (bool tf)</td></tr>
<tr class="separator:a8df19c6fe5d51d6e8e45c5bbf8ad0712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3e996c5dd4c3a11c6cf63aec9923c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a> (const std::string &amp;warnstr)</td></tr>
<tr class="separator:a9a3e996c5dd4c3a11c6cf63aec9923c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aebe3694552365933cac760655dea79e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe3694552365933cac760655dea79e6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>CleanupReactionModuleInstances</b> (void)</td></tr>
<tr class="separator:aebe3694552365933cac760655dea79e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc000eba7aff264659a36ddc731ac3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc000eba7aff264659a36ddc731ac3b"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>CreateReactionModule</b> (int nxyz, int nthreads)</td></tr>
<tr class="separator:a6bc000eba7aff264659a36ddc731ac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422a70a490d2cc69c5fe9812c53df0f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a422a70a490d2cc69c5fe9812c53df0f4"></a>
static <a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyReactionModule</b> (int n)</td></tr>
<tr class="separator:a422a70a490d2cc69c5fe9812c53df0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995d555d6f3ecba6d54672c5707d8e62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995d555d6f3ecba6d54672c5707d8e62"></a>
static <a class="el" href="class_phreeqc_r_m.html">PhreeqcRM</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetInstance</b> (int n)</td></tr>
<tr class="separator:a995d555d6f3ecba6d54672c5707d8e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb81551659517fc151adadf56f37c58e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb81551659517fc151adadf56f37c58e"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Char2TrimString</b> (const char *str, size_t l=0)</td></tr>
<tr class="separator:adb81551659517fc151adadf56f37c58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482ab8e602ced52f6973968548d7747c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a482ab8e602ced52f6973968548d7747c"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>FileExists</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a482ab8e602ced52f6973968548d7747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23d6e89554e06003e30d86b6df0ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f23d6e89554e06003e30d86b6df0ac3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>FileRename</b> (const std::string &amp;temp_name, const std::string &amp;name, const std::string &amp;backup_name)</td></tr>
<tr class="separator:a4f23d6e89554e06003e30d86b6df0ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a8a151670eb0072a6d57de8c0b76eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a8a151670eb0072a6d57de8c0b76eb"></a>
static <a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Int2IrmResult</b> (int r, bool positive_ok)</td></tr>
<tr class="separator:af2a8a151670eb0072a6d57de8c0b76eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a283decb9d3ad289cb1cb92f3bd4a7e5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a283decb9d3ad289cb1cb92f3bd4a7e5e"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellInitialize</b> (int i, int n_user_new, int *initial_conditions1, int *initial_conditions2, double *fraction1, std::set&lt; std::string &gt; &amp;error_set)</td></tr>
<tr class="separator:a283decb9d3ad289cb1cb92f3bd4a7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d00f1cac815f57a877a7d656813c271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d00f1cac815f57a877a7d656813c271"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CheckCells</b> ()</td></tr>
<tr class="separator:a1d00f1cac815f57a877a7d656813c271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9d886a278ac622db2e7f991801084a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9d886a278ac622db2e7f991801084a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CheckSelectedOutput</b> ()</td></tr>
<tr class="separator:aae9d886a278ac622db2e7f991801084a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb810962a804fbb687a191f01894a339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb810962a804fbb687a191f01894a339"></a>
IPhreeqc *&#160;</td><td class="memItemRight" valign="bottom"><b>Concentrations2UtilityH2O</b> (std::vector&lt; double &gt; &amp;c_in, std::vector&lt; double &gt; &amp;t_in, std::vector&lt; double &gt; &amp;p_in)</td></tr>
<tr class="separator:adb810962a804fbb687a191f01894a339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a7ffc8ec9e7f0d73e26b7b09f69559"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07a7ffc8ec9e7f0d73e26b7b09f69559"></a>
IPhreeqc *&#160;</td><td class="memItemRight" valign="bottom"><b>Concentrations2UtilityNoH2O</b> (std::vector&lt; double &gt; &amp;c_in, std::vector&lt; double &gt; &amp;t_in, std::vector&lt; double &gt; &amp;p_in)</td></tr>
<tr class="separator:a07a7ffc8ec9e7f0d73e26b7b09f69559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d219cf6ee8b2fbc2fc455e09674d2c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d219cf6ee8b2fbc2fc455e09674d2c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Concentrations2Solutions</b> (int n, std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="separator:a9d219cf6ee8b2fbc2fc455e09674d2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dabf9d0521ee04ba5b8fb5c2b8df8d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dabf9d0521ee04ba5b8fb5c2b8df8d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Concentrations2SolutionsH2O</b> (int n, std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="separator:a3dabf9d0521ee04ba5b8fb5c2b8df8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561137c90d96c54bbefb9aa579b012fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a561137c90d96c54bbefb9aa579b012fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Concentrations2SolutionsNoH2O</b> (int n, std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="separator:a561137c90d96c54bbefb9aa579b012fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daa295e9f24c85c66a78d7cc02ce00c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4daa295e9f24c85c66a78d7cc02ce00c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cxxSolution2concentration</b> (cxxSolution *cxxsoln_ptr, std::vector&lt; double &gt; &amp;d, double v, double dens)</td></tr>
<tr class="separator:a4daa295e9f24c85c66a78d7cc02ce00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263b9907a5129b7823d0a2156c9ff4ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a263b9907a5129b7823d0a2156c9ff4ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cxxSolution2concentrationH2O</b> (cxxSolution *cxxsoln_ptr, std::vector&lt; double &gt; &amp;d, double v, double dens)</td></tr>
<tr class="separator:a263b9907a5129b7823d0a2156c9ff4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660f466729ecc0908cd7eea70b757e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a660f466729ecc0908cd7eea70b757e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cxxSolution2concentrationNoH2O</b> (cxxSolution *cxxsoln_ptr, std::vector&lt; double &gt; &amp;d, double v, double dens)</td></tr>
<tr class="separator:a660f466729ecc0908cd7eea70b757e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be694c0efcb5bc36a86d3064390829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09be694c0efcb5bc36a86d3064390829"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GatherNchem</b> (std::vector&lt; double &gt; &amp;source, std::vector&lt; double &gt; &amp;destination)</td></tr>
<tr class="separator:a09be694c0efcb5bc36a86d3064390829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573625541c66a471e6c24d3fdf30950e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a573625541c66a471e6c24d3fdf30950e"></a>
cxxStorageBin &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Get_phreeqc_bin</b> (void)</td></tr>
<tr class="separator:a573625541c66a471e6c24d3fdf30950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070947c343b15a352eb64e760f019839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a070947c343b15a352eb64e760f019839"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HandleErrorsInternal</b> (std::vector&lt; int &gt; &amp;r)</td></tr>
<tr class="separator:a070947c343b15a352eb64e760f019839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765abc88f75876ea85b55249837f3241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765abc88f75876ea85b55249837f3241"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartitionUZ</b> (int n, int iphrq, int ihst, double new_frac)</td></tr>
<tr class="separator:a765abc88f75876ea85b55249837f3241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10c13015cab30c0152d3d349b96de9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac10c13015cab30c0152d3d349b96de9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RebalanceLoad</b> (void)</td></tr>
<tr class="separator:ac10c13015cab30c0152d3d349b96de9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dbec73b24029ed70dcb4812d6f4981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74dbec73b24029ed70dcb4812d6f4981"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RebalanceLoadPerCell</b> (void)</td></tr>
<tr class="separator:a74dbec73b24029ed70dcb4812d6f4981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d717aaf6c353b7306db6fe9ec8d10e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4d717aaf6c353b7306db6fe9ec8d10e"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RunCellsThread</b> (int i)</td></tr>
<tr class="separator:ab4d717aaf6c353b7306db6fe9ec8d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1521c70a313a7829129a094513f34378"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1521c70a313a7829129a094513f34378"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RunFileThread</b> (int n)</td></tr>
<tr class="separator:a1521c70a313a7829129a094513f34378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2840a8afe1579a8f6b6c3487a92d372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2840a8afe1579a8f6b6c3487a92d372"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RunStringThread</b> (int n, std::string &amp;input)</td></tr>
<tr class="separator:aa2840a8afe1579a8f6b6c3487a92d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf548d140ccdab79b0e62dfaab0ea12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf548d140ccdab79b0e62dfaab0ea12"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RunCellsThreadNoPrint</b> (int n)</td></tr>
<tr class="separator:a4bf548d140ccdab79b0e62dfaab0ea12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea030fa1626327d0daee3a460152dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaea030fa1626327d0daee3a460152dea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Scale_solids</b> (int n, int iphrq, double frac)</td></tr>
<tr class="separator:aaea030fa1626327d0daee3a460152dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef51b5998bf9f7a2818f04a759321b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acef51b5998bf9f7a2818f04a759321b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ScatterNchem</b> (double *d_array)</td></tr>
<tr class="separator:acef51b5998bf9f7a2818f04a759321b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2663732b34ede0c31ce295bb595b2839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2663732b34ede0c31ce295bb595b2839"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ScatterNchem</b> (int *i_array)</td></tr>
<tr class="separator:a2663732b34ede0c31ce295bb595b2839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7484f7e8e6b2cb829c94803cf2eddda2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7484f7e8e6b2cb829c94803cf2eddda2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ScatterNchem</b> (std::vector&lt; double &gt; &amp;source, std::vector&lt; double &gt; &amp;destination)</td></tr>
<tr class="separator:a7484f7e8e6b2cb829c94803cf2eddda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b61aade5fc5f309ae30c0d46327297"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5b61aade5fc5f309ae30c0d46327297"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ScatterNchem</b> (std::vector&lt; int &gt; &amp;source, std::vector&lt; int &gt; &amp;destination)</td></tr>
<tr class="separator:ae5b61aade5fc5f309ae30c0d46327297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895f993378332cc60bd3c485cf525f64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a895f993378332cc60bd3c485cf525f64"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SetChemistryFileName</b> (const char *prefix=NULL)</td></tr>
<tr class="separator:a895f993378332cc60bd3c485cf525f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0c4aaa660cc0688c1bee993899e86c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b0c4aaa660cc0688c1bee993899e86c"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SetDatabaseFileName</b> (const char *db=NULL)</td></tr>
<tr class="separator:a7b0c4aaa660cc0688c1bee993899e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6ba594138e74bec9eb473b358cd17a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6ba594138e74bec9eb473b358cd17a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEndCells</b> (void)</td></tr>
<tr class="separator:a4d6ba594138e74bec9eb473b358cd17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b159e9626f6a5408b823022ca253b2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b159e9626f6a5408b823022ca253b2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEndCellsHeterogeneous</b> (void)</td></tr>
<tr class="separator:a8b159e9626f6a5408b823022ca253b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b3fb3f4f011e2b3dddcd0c0bef88a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a763b3fb3f4f011e2b3dddcd0c0bef88a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>TimeStandardTask</b> (void)</td></tr>
<tr class="separator:a763b3fb3f4f011e2b3dddcd0c0bef88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f90a4566724bd2284f638ebe6a0065"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f90a4566724bd2284f638ebe6a0065"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TransferCells</b> (cxxStorageBin &amp;t_bin, int old, int nnew)</td></tr>
<tr class="separator:a88f90a4566724bd2284f638ebe6a0065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9ae28882e58eacd179f619d720b655"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9ae28882e58eacd179f619d720b655"></a>
<a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TransferCellsUZ</b> (std::ostringstream &amp;raw_stream, int old, int nnew)</td></tr>
<tr class="separator:a5f9ae28882e58eacd179f619d720b655"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adf1aac0aa8b9477e5b3cbc70c65a0a13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1aac0aa8b9477e5b3cbc70c65a0a13"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>component_h2o</b></td></tr>
<tr class="separator:adf1aac0aa8b9477e5b3cbc70c65a0a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854cf373961cbee9feeb2202a1c61315"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a854cf373961cbee9feeb2202a1c61315"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>database_file_name</b></td></tr>
<tr class="separator:a854cf373961cbee9feeb2202a1c61315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f7636285c1ea3a8c918f5339debff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0f7636285c1ea3a8c918f5339debff7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>chemistry_file_name</b></td></tr>
<tr class="separator:ad0f7636285c1ea3a8c918f5339debff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826bd1b962aff23b735924dcc471ab71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826bd1b962aff23b735924dcc471ab71"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>dump_file_name</b></td></tr>
<tr class="separator:a826bd1b962aff23b735924dcc471ab71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b64ff52ab85e017b7384705ea0fbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd8b64ff52ab85e017b7384705ea0fbd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>file_prefix</b></td></tr>
<tr class="separator:afd8b64ff52ab85e017b7384705ea0fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a21c9870f76c2d6c5054b92e99c238"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7a21c9870f76c2d6c5054b92e99c238"></a>
cxxStorageBin *&#160;</td><td class="memItemRight" valign="bottom"><b>phreeqc_bin</b></td></tr>
<tr class="separator:aa7a21c9870f76c2d6c5054b92e99c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32af53fbed13c4e50236252b1662547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac32af53fbed13c4e50236252b1662547"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_myself</b></td></tr>
<tr class="separator:ac32af53fbed13c4e50236252b1662547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb7e1891ce523b3ca00c22bc053fee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb7e1891ce523b3ca00c22bc053fee5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_tasks</b></td></tr>
<tr class="separator:aeeb7e1891ce523b3ca00c22bc053fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611fe706a83faeb8e82e5a0d7c1e9b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a611fe706a83faeb8e82e5a0d7c1e9b0f"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>components</b></td></tr>
<tr class="separator:a611fe706a83faeb8e82e5a0d7c1e9b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be195379cffac9e40de53fe932e3d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3be195379cffac9e40de53fe932e3d8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gfw</b></td></tr>
<tr class="separator:af3be195379cffac9e40de53fe932e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba36999b05d3ea02cc9c7c0771ca0b3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba36999b05d3ea02cc9c7c0771ca0b3f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>gfw_water</b></td></tr>
<tr class="separator:aba36999b05d3ea02cc9c7c0771ca0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfeb5e5eb5895526c2f145fc53fa5f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cfeb5e5eb5895526c2f145fc53fa5f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>partition_uz_solids</b></td></tr>
<tr class="separator:a2cfeb5e5eb5895526c2f145fc53fa5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66af1f37dc4c59a9c5b37172080d8be4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66af1f37dc4c59a9c5b37172080d8be4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nxyz</b></td></tr>
<tr class="separator:a66af1f37dc4c59a9c5b37172080d8be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d02c4c7340c4f44f396f55cab38162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d02c4c7340c4f44f396f55cab38162"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>count_chemistry</b></td></tr>
<tr class="separator:a01d02c4c7340c4f44f396f55cab38162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d5aa7fce1a14d8bddfb2c333ea9679"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d5aa7fce1a14d8bddfb2c333ea9679"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time</b></td></tr>
<tr class="separator:ab2d5aa7fce1a14d8bddfb2c333ea9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216048ea5d8bbcef641752b6d744ba8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa216048ea5d8bbcef641752b6d744ba8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time_step</b></td></tr>
<tr class="separator:aa216048ea5d8bbcef641752b6d744ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8928ca3d297685aa3deeb90fa9bae20f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8928ca3d297685aa3deeb90fa9bae20f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time_conversion</b></td></tr>
<tr class="separator:a8928ca3d297685aa3deeb90fa9bae20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebde289ba81fe0c7512018f6be3bb4b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebde289ba81fe0c7512018f6be3bb4b2"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>old_saturation_root</b></td></tr>
<tr class="separator:aebde289ba81fe0c7512018f6be3bb4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a0bb2309c5a6d16384e2ae875229b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5a0bb2309c5a6d16384e2ae875229b8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>old_saturation_worker</b></td></tr>
<tr class="separator:ac5a0bb2309c5a6d16384e2ae875229b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9113346927502b119ed79fdbc0a967cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9113346927502b119ed79fdbc0a967cf"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>saturation_root</b></td></tr>
<tr class="separator:a9113346927502b119ed79fdbc0a967cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cee0b8bb2a35c8460ac9bb606821b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45cee0b8bb2a35c8460ac9bb606821b8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>saturation_worker</b></td></tr>
<tr class="separator:a45cee0b8bb2a35c8460ac9bb606821b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0642204b36c9e902c9523c0187c2497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0642204b36c9e902c9523c0187c2497"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pressure_root</b></td></tr>
<tr class="separator:ac0642204b36c9e902c9523c0187c2497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a875bde53518dd6319a3392305988d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18a875bde53518dd6319a3392305988d"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pressure_worker</b></td></tr>
<tr class="separator:a18a875bde53518dd6319a3392305988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f207910778aee42c92a104289a3321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78f207910778aee42c92a104289a3321"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rv_root</b></td></tr>
<tr class="separator:a78f207910778aee42c92a104289a3321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac110c401d6b350f6138c457d0b2e1734"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac110c401d6b350f6138c457d0b2e1734"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rv_worker</b></td></tr>
<tr class="separator:ac110c401d6b350f6138c457d0b2e1734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c6fc146e5f855cfc57f72a9563048"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae62c6fc146e5f855cfc57f72a9563048"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>porosity_root</b></td></tr>
<tr class="separator:ae62c6fc146e5f855cfc57f72a9563048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac1df6429cc5268ae0daf187d7fc57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aac1df6429cc5268ae0daf187d7fc57"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>porosity_worker</b></td></tr>
<tr class="separator:a2aac1df6429cc5268ae0daf187d7fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acada4d19171fd89503f35cd092aa44f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acada4d19171fd89503f35cd092aa44f8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tempc_root</b></td></tr>
<tr class="separator:acada4d19171fd89503f35cd092aa44f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd817921a227e0ae0c436a82e68592b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd817921a227e0ae0c436a82e68592b8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tempc_worker</b></td></tr>
<tr class="separator:acd817921a227e0ae0c436a82e68592b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ad7e93596d7ee491256f9f7577f6b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57ad7e93596d7ee491256f9f7577f6b0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>density_root</b></td></tr>
<tr class="separator:a57ad7e93596d7ee491256f9f7577f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbde997f350c6e02a78ed7c2aa09f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bbde997f350c6e02a78ed7c2aa09f42"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>density_worker</b></td></tr>
<tr class="separator:a4bbde997f350c6e02a78ed7c2aa09f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785ee059ccbbcb158f2ae6623a287e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5785ee059ccbbcb158f2ae6623a287e2"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>solution_volume_root</b></td></tr>
<tr class="separator:a5785ee059ccbbcb158f2ae6623a287e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478988ac44d8164ca2b5e6e599c9eb5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478988ac44d8164ca2b5e6e599c9eb5d"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>solution_volume_worker</b></td></tr>
<tr class="separator:a478988ac44d8164ca2b5e6e599c9eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1719b78afc7d9765c42d87c0f392351e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1719b78afc7d9765c42d87c0f392351e"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_chem_mask_root</b></td></tr>
<tr class="separator:a1719b78afc7d9765c42d87c0f392351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614c4b3c97d5e33504ef3c99944f495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad614c4b3c97d5e33504ef3c99944f495"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_chem_mask_worker</b></td></tr>
<tr class="separator:ad614c4b3c97d5e33504ef3c99944f495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3671717761b1b81fbbe97f6d2bdd6b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3671717761b1b81fbbe97f6d2bdd6b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rebalance_by_cell</b></td></tr>
<tr class="separator:ab3671717761b1b81fbbe97f6d2bdd6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cae4e69ded793d00586c87a39b6ea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26cae4e69ded793d00586c87a39b6ea9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rebalance_fraction</b></td></tr>
<tr class="separator:a26cae4e69ded793d00586c87a39b6ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f1069c1c47da49254ce88bd054d8a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47f1069c1c47da49254ce88bd054d8a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_Solution</b></td></tr>
<tr class="separator:a47f1069c1c47da49254ce88bd054d8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64291d8002021310beec645ffe0c8eda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64291d8002021310beec645ffe0c8eda"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_PPassemblage</b></td></tr>
<tr class="separator:a64291d8002021310beec645ffe0c8eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c5ba5a7f6b4255f7f0b80bec1ceaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37c5ba5a7f6b4255f7f0b80bec1ceaf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_Exchange</b></td></tr>
<tr class="separator:aa37c5ba5a7f6b4255f7f0b80bec1ceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59fbd662d77ed8ebccd8a5e98715585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af59fbd662d77ed8ebccd8a5e98715585"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_Surface</b></td></tr>
<tr class="separator:af59fbd662d77ed8ebccd8a5e98715585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058af496db12b4b368012f934e403190"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a058af496db12b4b368012f934e403190"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_GasPhase</b></td></tr>
<tr class="separator:a058af496db12b4b368012f934e403190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ef35dc64591906d380a33361e0c3ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ef35dc64591906d380a33361e0c3ff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_SSassemblage</b></td></tr>
<tr class="separator:a13ef35dc64591906d380a33361e0c3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa461c89fe907937fe3a4ed927b56173f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa461c89fe907937fe3a4ed927b56173f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>units_Kinetics</b></td></tr>
<tr class="separator:aa461c89fe907937fe3a4ed927b56173f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed52007152a2ec854e603424fe1c97f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed52007152a2ec854e603424fe1c97f9"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>forward_mapping_root</b></td></tr>
<tr class="separator:aed52007152a2ec854e603424fe1c97f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3119926659313235ca2f75ee693694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d3119926659313235ca2f75ee693694"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>backward_mapping</b></td></tr>
<tr class="separator:a4d3119926659313235ca2f75ee693694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391d6cb3096eb18b56d1edb494e53d15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a391d6cb3096eb18b56d1edb494e53d15"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_solution_density_volume</b></td></tr>
<tr class="separator:a391d6cb3096eb18b56d1edb494e53d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98968611427af7a98a1546c64e6c1486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98968611427af7a98a1546c64e6c1486"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_chemistry_on</b></td></tr>
<tr class="separator:a98968611427af7a98a1546c64e6c1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a71b1b2cf2dff657cbf7232c7623567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a71b1b2cf2dff657cbf7232c7623567"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selected_output_on</b></td></tr>
<tr class="separator:a1a71b1b2cf2dff657cbf7232c7623567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4779c87a347398043e42d70057a48f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd4779c87a347398043e42d70057a48f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>error_count</b></td></tr>
<tr class="separator:abd4779c87a347398043e42d70057a48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0390a6e2313909daaa5741e21342d7b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0390a6e2313909daaa5741e21342d7b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>error_handler_mode</b></td></tr>
<tr class="separator:a0390a6e2313909daaa5741e21342d7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f85e0176919acaec3d2de9db2a01bfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f85e0176919acaec3d2de9db2a01bfc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>need_error_check</b></td></tr>
<tr class="separator:a2f85e0176919acaec3d2de9db2a01bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2310812203e6063baa0759c18fd2a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2310812203e6063baa0759c18fd2a93"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>phreeqcrm_error_string</b></td></tr>
<tr class="separator:aa2310812203e6063baa0759c18fd2a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6a46c4274b223ea03fb4a7b80f4a5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b6a46c4274b223ea03fb4a7b80f4a5a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nthreads</b></td></tr>
<tr class="separator:a2b6a46c4274b223ea03fb4a7b80f4a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307c9ccbef9314771321bf7f2f9b6c42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307c9ccbef9314771321bf7f2f9b6c42"></a>
std::vector&lt; IPhreeqcPhast * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workers</b></td></tr>
<tr class="separator:a307c9ccbef9314771321bf7f2f9b6c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf228e107fa8cb4588842e72cf91268d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf228e107fa8cb4588842e72cf91268d"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>start_cell</b></td></tr>
<tr class="separator:aaf228e107fa8cb4588842e72cf91268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1817a83029e2b0e84bac72ac3916d65e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1817a83029e2b0e84bac72ac3916d65e"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end_cell</b></td></tr>
<tr class="separator:a1817a83029e2b0e84bac72ac3916d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe0263661029204d39a0765da33aee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27fe0263661029204d39a0765da33aee"></a>
PHRQ_io *&#160;</td><td class="memItemRight" valign="bottom"><b>phreeqcrm_io</b></td></tr>
<tr class="separator:a27fe0263661029204d39a0765da33aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e342a22e19d6818d358c51e4b77657"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0e342a22e19d6818d358c51e4b77657"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>delete_phreeqcrm_io</b></td></tr>
<tr class="separator:ac0e342a22e19d6818d358c51e4b77657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ad268abb78e57da7bac20b593c2775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75ad268abb78e57da7bac20b593c2775"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_worker_callback_fortran</b> )(int *method)</td></tr>
<tr class="separator:a75ad268abb78e57da7bac20b593c2775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6deb296f1d8472adacfb40f2a8c6331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6deb296f1d8472adacfb40f2a8c6331"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_worker_callback_c</b> )(int *method, void *cookie)</td></tr>
<tr class="separator:ae6deb296f1d8472adacfb40f2a8c6331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07941135715ea172829dcfd04623da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07941135715ea172829dcfd04623da5"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_worker_callback_cookie</b></td></tr>
<tr class="separator:af07941135715ea172829dcfd04623da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a062fcb60b8fb6977e92729832ebf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a062fcb60b8fb6977e92729832ebf6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>species_save_on</b></td></tr>
<tr class="separator:a03a062fcb60b8fb6977e92729832ebf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa131638f286895ba6106b564a758cf03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa131638f286895ba6106b564a758cf03"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>species_names</b></td></tr>
<tr class="separator:aa131638f286895ba6106b564a758cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb651c24ae52821ff9d5c514bc5f705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb651c24ae52821ff9d5c514bc5f705"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>species_z</b></td></tr>
<tr class="separator:a9bb651c24ae52821ff9d5c514bc5f705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b194e1a88017c339cea4f6135a554c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b194e1a88017c339cea4f6135a554c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>species_d_25</b></td></tr>
<tr class="separator:a62b194e1a88017c339cea4f6135a554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6256553f73b9b8c13c3a59b330685d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6256553f73b9b8c13c3a59b330685d2"></a>
std::vector&lt; cxxNameDouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>species_stoichiometry</b></td></tr>
<tr class="separator:af6256553f73b9b8c13c3a59b330685d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1622eff75e94a399a7d1db14212925e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1622eff75e94a399a7d1db14212925e4"></a>
std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>s_num2rm_species_num</b></td></tr>
<tr class="separator:a1622eff75e94a399a7d1db14212925e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff6337289bec8e9135dc3756d3e72b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76ff6337289bec8e9135dc3756d3e72b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>standard_task_vector</b></td></tr>
<tr class="separator:a76ff6337289bec8e9135dc3756d3e72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918d0e6d56314923fa2c3649694f5f2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a918d0e6d56314923fa2c3649694f5f2e"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExchangeSpeciesNamesList</b></td></tr>
<tr class="separator:a918d0e6d56314923fa2c3649694f5f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac983eeb7d3a80a24990b3f63a38f029c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac983eeb7d3a80a24990b3f63a38f029c"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExchangeNamesList</b></td></tr>
<tr class="separator:ac983eeb7d3a80a24990b3f63a38f029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c05eec95db3b24a987aa7cb428692b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c05eec95db3b24a987aa7cb428692b"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceSpeciesNamesList</b></td></tr>
<tr class="separator:ae1c05eec95db3b24a987aa7cb428692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9db18ddf752484927debd92b940de0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9db18ddf752484927debd92b940de0e"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceTypesList</b></td></tr>
<tr class="separator:ae9db18ddf752484927debd92b940de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dc3b8c4cc6a47b58a2c2ab2558f231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81dc3b8c4cc6a47b58a2c2ab2558f231"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceNamesList</b></td></tr>
<tr class="separator:a81dc3b8c4cc6a47b58a2c2ab2558f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611111ea3ba8fdfff32712ee0437118c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a611111ea3ba8fdfff32712ee0437118c"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EquilibriumPhasesList</b></td></tr>
<tr class="separator:a611111ea3ba8fdfff32712ee0437118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0784ee75c2fedd0cc0acbcd55a2be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d0784ee75c2fedd0cc0acbcd55a2be5"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GasComponentsList</b></td></tr>
<tr class="separator:a8d0784ee75c2fedd0cc0acbcd55a2be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49288ecc9b11a83b3932ecd9c0bc5274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49288ecc9b11a83b3932ecd9c0bc5274"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KineticReactionsList</b></td></tr>
<tr class="separator:a49288ecc9b11a83b3932ecd9c0bc5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5306867c5c25e55e00661a035b83d214"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5306867c5c25e55e00661a035b83d214"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SolidSolutionComponentsList</b></td></tr>
<tr class="separator:a5306867c5c25e55e00661a035b83d214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a705e23a98fbc424fce44963a071fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a705e23a98fbc424fce44963a071fbf"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SolidSolutionNamesList</b></td></tr>
<tr class="separator:a0a705e23a98fbc424fce44963a071fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabac49011817dc5605642a83dbb460e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabac49011817dc5605642a83dbb460e2"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SINamesList</b></td></tr>
<tr class="separator:aabac49011817dc5605642a83dbb460e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Geochemical reaction module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adf01f0b9ab2101d9b073c205804b255e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_phreeqc_r_m.html">PhreeqcRM</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nxyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_count_or_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PHRQ_io *&#160;</td>
          <td class="paramname"><em>io</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for the PhreeqcRM reaction module. If the code is compiled with the preprocessor directive USE_OPENMP, the reaction module use OPENMP and multiple threads. If the code is compiled with the preprocessor directive USE_MPI, the reaction module will use MPI and multiple processes. If neither preprocessor directive is used, the reaction module will be serial (unparallelized). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nxyz</td><td>The number of grid cells in the users model. </td></tr>
    <tr><td class="paramname">thread_count_or_communicator</td><td>If multithreaded, the number of threads to use in parallel segments of the code. If <em>thread_count_or_communicator</em> is &lt;= 0, the number of threads is set equal to the number of processors in the computer. If multiprocessor, the MPI communicator to use within the reaction module. </td></tr>
    <tr><td class="paramname">io</td><td>Optionally, a PHRQ_io input/output object can be provided to the constructor. By default a PHRQ_io object is constructed to handle reading and writing files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int nxyz = 40;
#ifdef USE_MPI
  PhreeqcRM phreeqc_rm(nxyz, MPI_COMM_WORLD);
  int mpi_myself;
  if (MPI_Comm_rank(MPI_COMM_WORLD, &mpi_myself) != MPI_SUCCESS)
  {
    exit(4);
  }
  if (mpi_myself > 0)
  {
    phreeqc_rm.MpiWorker();
    return EXIT_SUCCESS;
  }
#else
  int nthreads = 3;
  PhreeqcRM phreeqc_rm(nxyz, nthreads);
#endif
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and all workers. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abf9eb39e299d0d44388367dd27900996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> CloseFiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the output and log files. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a> </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.CloseFiles();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called only by root. </dd></dl>

</div>
</div>
<a class="anchor" id="af91d035f4839205de54a34a0d62cf9e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPhreeqc* Concentrations2Utility </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>p_atm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>N</em> sets of component concentrations are converted to SOLUTIONs numbered 1-<em>n</em> in the Utility IPhreeqc. The solutions can be reacted and manipulated with the methods of IPhreeqc. If solution concentration units (<a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>) are per liter, one liter of solution is created in the Utility instance; if solution concentration units are mass fraction, one kilogram of solution is created in the Utility instance. The motivation for this method is the mixing of solutions in wells, where it may be necessary to calculate solution properties (pH for example) or react the mixture to form scale minerals. The code fragment below makes a mixture of concentrations and then calculates the pH of the mixture. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Vector of concentrations to be made SOLUTIONs in Utility IPhreeqc. Vector contains <em>n</em> values for each component (<a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>) in sequence. </td></tr>
    <tr><td class="paramname">tc</td><td>Vector of temperatures to apply to the SOLUTIONs, in degrees C. Vector of size <em>n</em>. </td></tr>
    <tr><td class="paramname">p_atm</td><td>Vector of pressures to apply to the SOLUTIONs, in atm. Vector of size <em>n</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector <double> c_well;
c_well.resize(1*ncomps, 0.0);
for (int i = 0; i < ncomps; i++)
{
  c_well[i] = 0.5 * c[0 + nxyz*i] + 0.5 * c[9 + nxyz*i];
}
std::vector<double> tc, p_atm;
tc.resize(1, 15.0);
p_atm.resize(1, 3.0);
IPhreeqc * util_ptr = phreeqc_rm.Concentrations2Utility(c_well, tc, p_atm);
input = "SELECTED_OUTPUT 5; -pH;RUN_CELLS; -cells 1";
int iphreeqc_result;
util_ptr->SetOutputFileName("utility_cpp.txt");
util_ptr->SetOutputFileOn(true);
iphreeqc_result = util_ptr->RunString(input.c_str());
phreeqc_rm.ErrorHandler(iphreeqc_result, "IPhreeqc RunString failed");
int vtype;
double pH;
char svalue[100];
util_ptr->SetCurrentSelectedOutputUserNumber(5);
iphreeqc_result = util_ptr->GetSelectedOutputValue2(1, 0, &vtype, &pH, svalue, 100);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called only by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e5f01e00ec7e9de4ab0f06a3c16e31d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> CreateMapping </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid2chem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a mapping from grid cells in the user's model to reaction cells for which chemistry needs to be run. The mapping is used to eliminate inactive cells and to use symmetry to decrease the number of cells for which chemistry must be run. The array <em>grid2chem</em> of size <em>nxyz</em> (the number of grid cells, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>) must contain the set of all integers 0 &lt;= <em>i</em> &lt; <em>count_chemistry</em>, where <em>count_chemistry</em> is a number less than or equal to <em>nxyz</em>. Inactive cells are assigned a negative integer. The mapping may be many-to-one to account for symmetry. Default is a one-to-one mapping&ndash;all user grid cells are reaction cells (equivalent to <em>grid2chem</em> values of 0,1,2,3,...,nxyz-1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid2chem</td><td>A vector of integers: Nonnegative is a reaction-cell number (0 based), negative is an inactive cell. Vector is of size <em>nxyz</em> (number of grid cells, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// For demonstation, two equivalent rows by symmetry
std::vector<int> grid2chem;
grid2chem.resize(nxyz, -1);
for (int i = 0; i < nxyz/2; i++)
{
  grid2chem[i] = i;
  grid2chem[i + nxyz/2] = i;
}
status = phreeqc_rm.CreateMapping(grid2chem);
if (status < 0) phreeqc_rm.DecodeError(status);
int nchem = phreeqc_rm.GetChemistryCellCount();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ac0574257be4e62ad314f61a1d9f015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecodeError </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <em>result</em> is negative, this method prints an error message corresponding to IRM_RESULT <em>result</em>. If <em>result</em> is non-negative, no action is taken. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>An IRM_RESULT value returned by one of the reaction-module methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>IRM_RESULT definition:</dt><dd> 
<CODE>
<PRE>
typedef enum {
  IRM_OK            =  0,  //Success
  IRM_OUTOFMEMORY   = -1,  //Failure, Out of memory
  IRM_BADVARTYPE    = -2,  //Failure, Invalid VAR type
  IRM_INVALIDARG    = -3,  //Failure, Invalid argument
  IRM_INVALIDROW    = -4,  //Failure, Invalid row
  IRM_INVALIDCOL    = -5,  //Failure, Invalid column
  IRM_BADINSTANCE   = -6,  //Failure, Invalid rm instance id
  IRM_FAIL          = -7,  //Failure, Unspecified
} IRM_RESULT;
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.CreateMapping(grid2chem);
phreeqc_rm.DecodeError(status);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Can be called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a69bc339ef18879fc6747c7cb3ee8b407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> DumpModule </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dump_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the contents of all workers to file in _RAW formats (see appendix of PHREEQC version 3 manual), including SOLUTIONs and all reactants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dump_on</td><td>Signal for writing the dump file, true or false. </td></tr>
    <tr><td class="paramname">append</td><td>Signal to append to the contents of the dump file, true or false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a6d70b6e7cf9071181291bdcab7603a9c">SetDumpFileName</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
bool dump_on = true;
bool append = false;
status = phreeqc_rm.SetDumpFileName("advection_cpp.dmp");
status = phreeqc_rm.DumpModule(dump_on, append);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root; workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acb864f4e9d7814f505ded458cb7fc01b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ErrorHandler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>e_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks <em>result</em> for an error code. If result is negative, the result is decoded (<a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>), and printed as an error message along with the <em>e_string</em>, and an exception is thrown. If the result is nonnegative, no action is taken. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>IRM_RESULT to be checked for an error. </td></tr>
    <tr><td class="paramname">e_string</td><td>String to be printed if an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>, <a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
iphreeqc_result = util_ptr->RunString(input.c_str());
if (iphreeqc_result != 0)
{
  phreeqc_rm.ErrorHandler(IRM_FAIL, "IPhreeqc RunString failed");
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ad62514bca8a5119822e58a75db087cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ErrorMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>error_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an error message to the screen, the output file, and the log file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error_string</td><td>String to be printed. </td></tr>
    <tr><td class="paramname">prepend</td><td>True, prepends <em>error_string</em> with "Error: "; false, <em>error_string</em> is used with no prepended text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
phreeqc_rm.ErrorMessage("Goodbye world");
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers; root writes to output and log files. </dd></dl>

</div>
</div>
<a class="anchor" id="ab292c626fe8a387d1144e139722ab43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FindComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method accumulates a list of elements. Elements are those that have been defined in a solution or any other reactant (EQUILIBRIUM_PHASE, KINETICS, and others), including charge imbalance. This method can be called multiple times and the list that is created is cummulative. The list is the set of components that needs to be transported. By default the list includes water, excess H and excess O (the H and O not contained in water); alternatively, the list may be set to contain total H and total O (<a class="el" href="class_phreeqc_r_m.html#ad61e9d1d88b23b5da1dad1eb35e415b1">SetComponentH2O</a>), which requires transport results to be accurate to eight or nine significant digits. If multicomponent diffusion (MCD) is to be modeled, there is a capability to retrieve aqueous species concentrations (<a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>) and to set new solution concentrations after MCD by using individual species concentrations (<a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>). To use these methods the save-species property needs to be turned on (<a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>). If the save-species property is on, FindComponents will generate a list of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>), their diffusion coefficients at 25 C (<a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>), and their charge (<a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of components currently in the list, or IRM_RESULT error code (negative value, see <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a59a63b9d464b9b91e1a18efdcf9900c7">GetComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#ad61e9d1d88b23b5da1dad1eb35e415b1">SetComponentH2O</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>The  FindComponents method also generates lists of reactants&ndash;equilibrium phases,</dt><dd>exchangers, gas components, kinetic reactants, solid solution components, and surfaces. The lists are cumulative, including all reactants that were defined in the initial phreeqc instance at any time FindComponents was called. In addition, a list of phases is generated for which saturation indices may be calculated from the cumulative list of components. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>also <a class="el" href="class_phreeqc_r_m.html#aab675139c6a769304ef5acf795febbbf">GetEquilibriumPhases</a>, <a class="el" href="class_phreeqc_r_m.html#a17aadf145d1edd3a38213290608e903c">GetEquilibriumPhasesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a54fd5597312c707f29369e0a74824311">GetExchangeNames</a>, <a class="el" href="class_phreeqc_r_m.html#a3d4ef60da8a54fcabf0aa88ba4cf0686">GetExchangeSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#af38e24e1cb590d34fd97f395ff8506ba">GetExchangeSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a324da78ebfd28319bb7545a0132e4361">GetGasComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a7aa8e74a7b7454c14755f017c778c62d">GetGasComponentsCount</a>, <a class="el" href="class_phreeqc_r_m.html#a355346f344d47b43bfb55815e9ac0f6e">GetKineticReactions</a>, <a class="el" href="class_phreeqc_r_m.html#aa50317758e3ac3152ae60cf8f8d6efe0">GetKineticReactionsCount</a>, <a class="el" href="class_phreeqc_r_m.html#a7bf5f318493ca94de71fbf839910f379">GetSICount</a>, <a class="el" href="class_phreeqc_r_m.html#a9f47533d63d2df6972acbbfef7d5e037">GetSINames</a>, <a class="el" href="class_phreeqc_r_m.html#afbdf4e16dd8c17839ea4e26ad2e0711b">GetSolidSolutionComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aa69ecfcf73c2ca674b4a02377bc58e1f">GetSolidSolutionComponentsCount</a>, <a class="el" href="class_phreeqc_r_m.html#a20f694b09fa03c7c120d5333ee05d4f8">GetSolidSolutionNames</a>, <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a>, <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int ncomps = phreeqc_rm.FindComponents();
const std::vector<std::string> &components = phreeqc_rm.GetComponents();
const std::vector < double > & gfw = phreeqc_rm.GetGfw();
for (int i = 0; i < ncomps; i++)
{
  std::ostringstream strm;
  strm.width(10);
  strm << components[i] << "    " << gfw[i] << "\n";
  phreeqc_rm.OutputMessage(strm.str());
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac18e1842d69e819df1737a08f4190c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector &lt;int&gt; &gt;&amp; GetBackwardMapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of vectors, where the <em>nth</em> vector is a vector of grid-cell numbers that are mapped to reaction-cell number <em>n</em>. Each reaction-cell number has a vector of one or more grid-cell numbers. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>of vectors of ints. For each reaction cell <em>n</em>, the <em>nth</em> vector in the vector of vectors contains the grid-cell numbers that map to the reaction cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>, <a class="el" href="class_phreeqc_r_m.html#a1e0baa43d30518ec4fb20872213a6663">GetForwardMapping</a>, <a class="el" href="class_phreeqc_r_m.html#ad47b5eee0491908654645ebb899ecb63">GetChemistryCellCount</a>, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector < std::vector <int> > & back = phreeqcrm_ptr->GetBackwardMapping();
if (option == "HYDRAULIC_K")
{
  return (*data_ptr->hydraulic_K)[back[rm_cell_number][0]];
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root or workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ad47b5eee0491908654645ebb899ecb63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetChemistryCellCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of reaction cells in the reaction module. The number of reaction cells is defined by the set of non-negative integers in the mapping from grid cells (<a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>), or, by default, the number of grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). The number of reaction cells is less than or equal to the number of grid cells in the user's model. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of reaction cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.CreateMapping(grid2chem);
std::ostringstream oss;
oss << "Number of reaction cells in the reaction module: "
    << phreeqc_rm.GetChemistryCellCount() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a25ac2b0172e9aa11f3537c74d4e1aa7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetComponentCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of components in the reaction-module component list. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of components in the reaction-module component list. The component list is generated by calls to <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>. The return value from the last call to <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> is equal to the return value from GetComponentCount. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a59a63b9d464b9b91e1a18efdcf9900c7">GetComponents</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Number of components for transport: " << phreeqc_rm.GetComponentCount() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a63b9d464b9b91e1a18efdcf9900c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetComponents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the reaction-module component list that was generated by calls to <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a component name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a> </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<std::string> &components = phreeqc_rm.GetComponents();
const std::vector < double > & gfw = phreeqc_rm.GetGfw();
int ncomps = phreeqc_rm.GetComponentCount();
for (int i = 0; i < ncomps; i++)
{
  std::ostringstream strm;
  strm.width(10);
  strm << components[i] << "    " << gfw[i] << "\n";
  phreeqc_rm.OutputMessage(strm.str());
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aa48d2ebd2e0efed5c49431c191159462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetConcentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer solution concentrations from each reaction cell to the concentration vector given in the argument list (<em>c</em>). Units of concentration for <em>c</em> are defined by <a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>. For per liter concentration units, solution volume is used to calculate the concentrations for <em>c</em>. For mass-fraction concentration units, the solution mass is used to calculate concentrations for <em>c</em>. Two options are available for the volume and mass of solution that are used in converting to transport concentrations: (1) the volume and mass of solution are calculated by PHREEQC, or (2) the volume of solution is the product of saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>), and the mass of solution is volume times density as defined by <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>. <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a> determines which option is used. For option 1, the databases that have partial molar volume definitions needed to accurately calculate solution volume are phreeqc.dat, Amm.dat, and pitzer.dat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Vector to receive the concentrations. Dimension of the vector is set to <em>ncomps</em> times <em>nxyz</em>, where, ncomps is the result of <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> or <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>, and <em>nxyz</em> is the number of user grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Values for inactive cells are set to 1e30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>, <a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>, <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> c;
status = phreeqc_rm.RunCells();
status = phreeqc_rm.GetConcentrations(c);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac821fe10814851b2355c32d71bf0e43a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetDatabaseFileName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the file name of the database. Should be called after <a class="el" href="class_phreeqc_r_m.html#a471917c3a3b72d32a3aff2277c846ce4">LoadDatabase</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>The file name defined in <a class="el" href="class_phreeqc_r_m.html#a471917c3a3b72d32a3aff2277c846ce4">LoadDatabase</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a471917c3a3b72d32a3aff2277c846ce4">LoadDatabase</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Database: " << phreeqc_rm.GetDatabaseFileName() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a1890077c451ea8864e441dbf4bd45a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetDensity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>density</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer solution densities from the reaction-module workers to the vector given in the argument list (<em>density</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>Vector to receive the densities. Dimension of the array is set to <em>nxyz</em>, where <em>nxyz</em> is the number of user grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Values for inactive cells are set to 1e30. Densities are those calculated by the reaction module. Only the following databases distributed with PhreeqcRM have molar volume information needed to accurately calculate density: phreeqc.dat, Amm.dat, and pitzer.dat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a>, <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.RunCells();
status = phreeqc_rm.GetConcentrations(c);
std::vector<double> density;
status = phreeqc_rm.GetDensity(density);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acc4ef701a669817c88287cfe2a24fe21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int&gt;&amp; GetEndCell </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of integers that contains the largest reaction-cell number assigned to each worker. Each worker is assigned a range of reaction-cell numbers that are run during a call to <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>. The range of reaction cells for a worker may vary as load rebalancing occurs. At any point in the calculations, the first cell and last cell to be run by a worker can be found in the vectors returned by <a class="el" href="class_phreeqc_r_m.html#aab7b8935b7c6837a172503950e1f1e92">GetStartCell</a> and <a class="el" href="class_phreeqc_r_m.html#acc4ef701a669817c88287cfe2a24fe21">GetEndCell</a>. Each method returns a vector of integers that has length of the number of threads (<a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>), if using OPENMP, or the number of processes (<a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>), if using MPI.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>Vector of integers, one for each worker, that gives the last reaction cell to be run by each worker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aab7b8935b7c6837a172503950e1f1e92">GetStartCell</a>, <a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>, <a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Current distribution of cells for workers\n";
oss << "Worker First Cell   Last Cell\n";
int n;
n = phreeqc_rm.GetThreadCount() * phreeqc_rm.GetMpiTasks();
for (int i = 0; i < n; i++)
{
    oss << i << "      "
        << phreeqc_rm.GetStartCell()[i]
        << "            "
        << phreeqc_rm.GetEndCell()[i] << "\n";
}
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aab675139c6a769304ef5acf795febbbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetEquilibriumPhases </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of all equilibrium phases. The list includes all phases included in any EQUILIBRIUM_PHASES definitions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#aab675139c6a769304ef5acf795febbbf">GetEquilibriumPhases</a>. This method may be useful when generating selected output definitions related to equilibrium phases.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique equilibrium phases name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a17aadf145d1edd3a38213290608e903c">GetEquilibriumPhasesCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -equilibrium_phases " << "\n";
// equilibrium phases
const std::vector<std::string> &eq_phases = phreeqc_rm.GetEquilibriumPhases();
for (size_t i = 0; i < phreeqc_rm.GetEquilibriumPhasesCount(); i++)
{
oss << "    " << eq_phases[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a17aadf145d1edd3a38213290608e903c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetEquilibriumPhasesCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of equilibrium phases in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a17aadf145d1edd3a38213290608e903c">GetEquilibriumPhasesCount</a>. This method may be useful when generating selected output definitions related to equilibrium phases.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of equilibrium phases in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aab675139c6a769304ef5acf795febbbf">GetEquilibriumPhases</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -equilibrium_phases " << "\n";
// equilibrium phases
const std::vector<std::string> &eq_phases = phreeqc_rm.GetEquilibriumPhases();
for (size_t i = 0; i < phreeqc_rm.GetEquilibriumPhasesCount(); i++)
{
oss << "    " << eq_phases[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="af657da23ae5a2bfbde593c4f05d69e6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetErrorHandlerMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the setting for the action to be taken when the reaction module encounters an error. Options are 0, return to calling program with an error return code (default); 1, throw an exception, which can be caught in C++ (for C and Fortran, the program will exit); 2, attempt to exit gracefully. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>Current setting for the error handling mode: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a06c01d10280887c3ace8e0fbe179baa2">SetErrorHandlerMode</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Error handler mode: " << phreeqc_rm.GetErrorHandlerMode() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a0769fc515bc2738ce991d4e81ded7fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetErrorString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a standard string containing error messages related to the last call to a PhreeqcRM method. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Error</td><td>messages related to the last call to a PhreeqcRM method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af657da23ae5a2bfbde593c4f05d69e6c">GetErrorHandlerMode</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
if (status != IRM_OK)
{
  std::cerr << phreeqc_rm.GetErrorString();
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a54fd5597312c707f29369e0a74824311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetExchangeNames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of exchange names (such as "X") that correspond with the exchange species names. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a54fd5597312c707f29369e0a74824311">GetExchangeNames</a>. The exchange names vector is the same length as the exchange species names vector and provides the corresponding exchange site. This method may be useful when generating selected output definitions related to exchangers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is an exchange name corresponding to the exchange species vector; an exchange name may occur multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#af38e24e1cb590d34fd97f395ff8506ba">GetExchangeSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a3d4ef60da8a54fcabf0aa88ba4cf0686">GetExchangeSpecies</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of exchange species
const std::vector<std::string> &ex_species = phreeqc_rm.GetExchangeSpecies();
const std::vector<std::string> &ex_names = phreeqc_rm.GetExchangeNames();
for (size_t i = 0; i < phreeqc_rm.GetExchangeSpeciesCount(); i++)
{

oss << "    ";
oss.width(15);
oss << std::left << ex_species[i];
oss << " # " << ex_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d4ef60da8a54fcabf0aa88ba4cf0686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetExchangeSpecies </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of exchange species names (such as "NaX"). The list of exchange species (such as "NaX") is derived from the list of components (<a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>) and the list of all exchange names (such as "X") that are included in EXCHANGE definitions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a3d4ef60da8a54fcabf0aa88ba4cf0686">GetExchangeSpecies</a>. This method may be useful when generating selected output definitions related to exchangers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique exchange species name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#af38e24e1cb590d34fd97f395ff8506ba">GetExchangeSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a54fd5597312c707f29369e0a74824311">GetExchangeNames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of exchange species
const std::vector<std::string> &ex_species = phreeqc_rm.GetExchangeSpecies();
const std::vector<std::string> &ex_names = phreeqc_rm.GetExchangeNames();
for (size_t i = 0; i < phreeqc_rm.GetExchangeSpeciesCount(); i++)
{

oss << "    ";
oss.width(15);
oss << std::left << ex_species[i];
oss << " # " << ex_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="af38e24e1cb590d34fd97f395ff8506ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetExchangeSpeciesCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of exchange species in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#af38e24e1cb590d34fd97f395ff8506ba">GetExchangeSpeciesCount</a>. This method may be useful when generating selected output definitions related to exchangers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of exchange species in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a3d4ef60da8a54fcabf0aa88ba4cf0686">GetExchangeSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#a54fd5597312c707f29369e0a74824311">GetExchangeNames</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of exchange species
const std::vector<std::string> &ex_species = phreeqc_rm.GetExchangeSpecies();
const std::vector<std::string> &ex_names = phreeqc_rm.GetExchangeNames();
for (size_t i = 0; i < phreeqc_rm.GetExchangeSpeciesCount(); i++)
{

oss << "    ";
oss.width(15);
oss << std::left << ex_species[i];
oss << " # " << ex_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a097034fe3815caf183fb2635a8559c91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetFilePrefix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the file prefix for the output (.chem.txt) and log files (.log.txt). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>The file prefix as set by <a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a>, or "myrun", by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "File prefix: " << phreeqc_rm.GetFilePrefix() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0baa43d30518ec4fb20872213a6663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt;&amp; GetForwardMapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a vector of ints that is a mapping from grid cells to reaction cells. The mapping is used to eliminate cells that are inactive and cells that are unnecessary because of symmetry from the list of cells for which reactions must be run. The mapping may be many-to-one to account for symmetry. The mapping is set by <a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>, or, by default, is a one-to-one mapping&ndash;all grid cells are reaction cells (vector contains 0,1,2,3,...,<em>nxyz-1</em>). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector &lt; int &gt;&amp; A vector of integers of size <em>nxyz</em> (number of grid cells, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Nonnegative is a reaction-cell number (0 based), negative is an inactive cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<int> &f_map = phreeqc_rm.GetForwardMapping();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a324da78ebfd28319bb7545a0132e4361"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetGasComponents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of all gas components in the initial-phreeqc module. The list includes all gas components included in any GAS_PHASE definitions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a324da78ebfd28319bb7545a0132e4361">GetGasComponents</a>. This method may be useful when generating selected output definitions related to gas phases.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique gas component name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a7aa8e74a7b7454c14755f017c778c62d">GetGasComponentsCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -gases " << "\n";
// gas components
const std::vector<std::string> &gas_phases = phreeqc_rm.GetGasComponents();
for (size_t i = 0; i < phreeqc_rm.GetGasComponentsCount(); i++)
{
oss << "    " << gas_phases[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a7aa8e74a7b7454c14755f017c778c62d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetGasComponentsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of gas phase components in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a7aa8e74a7b7454c14755f017c778c62d">GetGasComponentsCount</a>. This method may be useful when generating selected output definitions related to gas phases.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of gas phase components in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a324da78ebfd28319bb7545a0132e4361">GetGasComponents</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -gases " << "\n";
// gas components
const std::vector<std::string> &gas_phases = phreeqc_rm.GetGasComponents();
for (size_t i = 0; i < phreeqc_rm.GetGasComponentsCount(); i++)
{
oss << "    " << gas_phases[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="ab83619a4a93f185ebd427f10c5b41306"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt;&amp; GetGfw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a vector of doubles that contains the gram-formula weight of each component. Called after <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>. Order of weights corresponds to the list of components from <a class="el" href="class_phreeqc_r_m.html#a59a63b9d464b9b91e1a18efdcf9900c7">GetComponents</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;double&gt;&amp; A vector of doubles; each value is a component gram-formula weight, g/mol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a59a63b9d464b9b91e1a18efdcf9900c7">GetComponents</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<std::string> &components = phreeqc_rm.GetComponents();
const std::vector < double > & gfw = phreeqc_rm.GetGfw();
int ncomps = phreeqc_rm.GetComponentCount();
for (int i = 0; i < ncomps; i++)
{
  std::ostringstream strm;
  strm.width(10);
  strm << components[i] << "    " << gfw[i] << "\n";
  phreeqc_rm.OutputMessage(strm.str());
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e0a9fa184dd8c8568b74cd5c10091c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetGridCellCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of grid cells in the user's model, which is defined in the call to the constructor for the reaction module. The mapping from grid cells to reaction cells is defined by <a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>. The number of reaction cells may be less than the number of grid cells if there are inactive regions or there is symmetry in the model definition. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of grid cells in the user's model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a> , <a class="el" href="class_phreeqc_r_m.html#a6e5f01e00ec7e9de4ab0f06a3c16e31d">CreateMapping</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Number of grid cells in the user's model: " << phreeqc_rm.GetGridCellCount() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ac492b8e6e7d0380ec37ff283dd08f2c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPhreeqc* GetIPhreeqcPointer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an IPhreeqc pointer to the <em>ith</em> IPhreeqc instance in the reaction module. For the threaded version, there are <em>nthreads</em> + 2 IPhreeqc instances, where <em>nthreads</em> is defined in the constructor (<a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>). The number of threads can be determined by <a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>. The first <em>nthreads</em> (0 based) instances will be the workers, the next (<em>nthreads</em>) is the InitialPhreeqc instance, and the next (<em>nthreads</em> + 1) is the Utility instance. Getting the IPhreeqc pointer for one of these instances allows the user to use any of the IPhreeqc methods on that instance. For MPI, each process has exactly three IPhreeqc instances, one worker (number 0), one InitialPhreeqc instance (number 1), and one Utility instance (number 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the IPhreeqc instance (0 based) to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IPhreeqc</td><td>pointer to the <em>ith</em> IPhreeqc instance (0 based) in the reaction module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>, <a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>. See IPhreeqc documentation for descriptions of IPhreeqc methods. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// Utility pointer is worker nthreads + 1
IPhreeqc * util_ptr = phreeqc_rm.GetIPhreeqcPointer(phreeqc_rm.GetThreadCount() + 1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a355346f344d47b43bfb55815e9ac0f6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetKineticReactions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of all kinetic reactions in the initial-phreeqc module. The list includes all kinetic reactions included in any KINETICS definitions in the reaction model. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a355346f344d47b43bfb55815e9ac0f6e">GetKineticReactions</a>. This method may be useful when generating selected output definitions related to kinetic reactions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique kinetic reaction name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aa50317758e3ac3152ae60cf8f8d6efe0">GetKineticReactionsCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -kinetics " << "\n";
// kinetic reactions
const std::vector<std::string> &kin_reactions = phreeqc_rm.GetKineticReactions();
for (size_t i = 0; i < phreeqc_rm.GetKineticReactionsCount(); i++)
{
oss << "    " << kin_reactions[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="aa50317758e3ac3152ae60cf8f8d6efe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetKineticReactionsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of kinetic reactions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#aa50317758e3ac3152ae60cf8f8d6efe0">GetKineticReactionsCount</a>. This method may be useful when generating selected output definitions related to kinetic reactions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of kinetic reactions in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a355346f344d47b43bfb55815e9ac0f6e">GetKineticReactions</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -kinetics " << "\n";
// kinetic reactions
const std::vector<std::string> &kin_reactions = phreeqc_rm.GetKineticReactions();
for (size_t i = 0; i < phreeqc_rm.GetKineticReactionsCount(); i++)
{
oss << "    " << kin_reactions[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b6435a77f5409c10ebfd8c70cb6a309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetMpiMyself </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the MPI process (task) number. For the MPI version, the root task number is zero, and all MPI tasks have unique task numbers greater than zero. The number of tasks can be obtained with <a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>. The number of tasks and computer hosts is determined at run time by the mpiexec command, and the number of reaction-module processes is defined by the communicator used in constructing the reaction modules (<a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>). For the OPENMP version, the task number is always zero, and the result of <a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a> is one. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>MPI task number for a process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>, <a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "MPI task number: " << phreeqc_rm.GetMpiMyself() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a767aba1bbc547eec71cb0067854b8a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetMpiTasks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of MPI processes (tasks) assigned to the reaction module. For the MPI version, the number of tasks and computer hosts is specified at run time by the mpiexec command. The number of MPI processes used for reaction calculations is determined by the MPI communicator used in constructing the reaction modules. The communicator may define a subset of the total number of MPI processes. The root task number is zero, and all other MPI tasks have unique task numbers greater than zero. For the OPENMP version, the number of tasks is one, and the task number returned by <a class="el" href="class_phreeqc_r_m.html#a5b6435a77f5409c10ebfd8c70cb6a309">GetMpiMyself</a> is zero. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of MPI processes assigned to the reaction module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a5b6435a77f5409c10ebfd8c70cb6a309">GetMpiMyself</a>, <a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Number of MPI processes: " << phreeqc_rm.GetMpiTasks() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="af7eb8523bff2a58b0ba1c3835f5ffb92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetNthSelectedOutputUserNumber </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user number for the <em>nth</em> selected-output definition. Definitions are sorted by user number. Phreeqc allows multiple selected-output definitions, each of which is assigned a nonnegative integer identifier by the user. The number of definitions can be obtained by <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>. To cycle through all of the definitions, GetNthSelectedOutputUserNumber can be used to identify the user number for each selected-output definition in sequence. <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> is then used to select that user number for selected-output processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The sequence number of the selected-output definition for which the user number will be returned. Fortran, 1 based; C, 0 based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>user number of the <em>nth</em> selected-output definition, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::cerr << "Selected output sequence number: " << isel << "\n";
  std::cerr << "Selected output user number:     " << n_user << "\n";
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  // Process results here
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a730bd52b5380331c67d47960bb096f00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GetPartitionUZSolids </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the setting for partitioning solids between the saturated and unsaturated parts of a partially saturated cell. The option is intended to be used by saturated-only flow codes that allow a variable water table. The value has meaning only when saturations less than 1.0 are encountered. The partially saturated cells may have a small water-to-rock ratio that causes reactions to proceed slowly relative to fully saturated cells. By setting <a class="el" href="class_phreeqc_r_m.html#a999cacdcaddc4b9c20b7a00ee7ea9f0b">SetPartitionUZSolids</a> to true, the amounts of solids and gases are partioned according to the saturation. If a cell has a saturation of 0.5, then the water interacts with only half of the solids and gases; the other half is unreactive until the water table rises. As the saturation in a cell varies, solids and gases are transferred between the saturated and unsaturated (unreactive) reservoirs of the cell. Unsaturated-zone flow and transport codes will probably use the default (false), which assumes all gases and solids are reactive regardless of saturation. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td><em>True</em>, the fraction of solids and gases available for reaction is equal to the saturation; <em>False</em> (default), all solids and gases are reactive regardless of saturation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a999cacdcaddc4b9c20b7a00ee7ea9f0b">SetPartitionUZSolids</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "Partioning of UZ solids: " << phreeqc_rm.GetPartitionUZSolids();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="af783c5401d3f2758fb65e0fb88fd9ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; GetPressure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pressure for each cell. By default, the pressure vector is initialized with 1 atm; if <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a> has not been called, worker solutions will have pressures as defined in input files (<a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a>) or input strings (<a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>); if <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a> has been called, worker solutions will have the pressures as defined by <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>. Pressure effects are considered by three PHREEQC databases: phreeqc.dat, Amm.dat, and pitzer.dat. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;double&gt;&amp; A vector reference to the pressures in each cell, in atm. Size of vector is <em>nxyz</em>, the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>, <a class="el" href="class_phreeqc_r_m.html#a296b63a1e849bd0b56189deca5b434a4">GetTemperature</a>, <a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<double> & p_atm = phreeqc_rm.GetPressure();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fb0082dd5d1d4f04e0fb53f08c354ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; GetPrintChemistryMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the vector of print flags that enable or disable detailed output for each cell. Printing for a cell will occur only when the printing is enabled with <a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>, and the value in the vector for the cell is 1. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;int&gt;</td><td>&amp; Vector of integers. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). A value of 0 for a cell indicates printing is disabled; a value of 1 for a cell indicates printing is enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<int> & print_chemistry_mask1 = phreeqc_rm.GetPrintChemistryMask();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a95608dd9d130371e5373b58629beadc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;bool&gt;&amp; GetPrintChemistryOn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector reference to the current print flags for detailed output for the three sets of IPhreeqc instances: the workers, the InitialPhreeqc instance, and the Utility instance. Dimension of the vector is 3. Printing of detailed output from reaction calculations to the output file is enabled when the vector value is true, disabled when false. The detailed output prints all of the output typical of a PHREEQC reaction calculation, which includes solution descriptions and the compositions of all other reactants. The output can be several hundred lines per cell, which can lead to a very large output file (prefix.chem.txt, <a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>). For the worker instances, the output can be limited to a set of cells (<a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a>) and, in general, the amount of information printed can be limited by use of options in the PRINT data block of PHREEQC (applied by using <a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a> or <a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>). Printing the detailed output for the workers is generally used only for debugging, and PhreeqcRM will run faster when printing detailed output for the workers is disabled (<a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;bool&gt; &amp; Print flag for the workers, InitialPhreeqc, and Utility IPhreeqc instances, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>, <a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<bool> & print_on = phreeqc_rm.GetPrintChemistryOn();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e44060d9acad18e13a2acc5a589b9d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GetRebalanceByCell </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the load-rebalancing method used for parallel processing. PhreeqcRM attempts to rebalance the load of each thread or process such that each thread or process takes the same amount of time to run its part of a <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> calculation. Two algorithms are available: one accounts for cells that were not run because saturation was zero (true), and the other uses the average time to run all of the cells assigned to a process or thread (false), . The methods are similar, but preliminary results indicate the default is better in most cases. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td><em>True</em> indicates individual cell run times are used in rebalancing (default); <em>False</em>, indicates average run times are used in rebalancing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a899c14198741359c3405507ea6022879">GetRebalanceFraction</a>, <a class="el" href="class_phreeqc_r_m.html#a41f2b742b0e4b9d8ba180202ca9ee438">SetRebalanceByCell</a>, <a class="el" href="class_phreeqc_r_m.html#a136d9ac45da1ab013f5d9f7236d55850">SetRebalanceFraction</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
bool rebalance = phreeqc_rm.GetRebalanceByCell();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a899c14198741359c3405507ea6022879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GetRebalanceFraction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the fraction used to determine the number of cells to transfer among threads or processes. PhreeqcRM attempts to rebalance the load of each thread or process such that each thread or process takes the same amount of time to run its part of a <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> calculation. The rebalancing transfers cell calculations among threads or processes to try to achieve an optimum balance. <a class="el" href="class_phreeqc_r_m.html#a136d9ac45da1ab013f5d9f7236d55850">SetRebalanceFraction</a> adjusts the calculated optimum number of cell transfers by a fraction from 0 to 1.0 to determine the number of cell transfers that actually are made. A value of zero eliminates load rebalancing. A value less than 1.0 is suggested to avoid possible oscillations, where too many cells are transferred at one iteration, requiring reverse transfers at the next iteration. Default is 0.5. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>Fraction used in rebalance, 0.0 to 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a9e44060d9acad18e13a2acc5a589b9d5">GetRebalanceByCell</a>, <a class="el" href="class_phreeqc_r_m.html#a41f2b742b0e4b9d8ba180202ca9ee438">SetRebalanceByCell</a>, <a class="el" href="class_phreeqc_r_m.html#a136d9ac45da1ab013f5d9f7236d55850">SetRebalanceFraction</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
double f_rebalance = phreeqc_rm.GetRebalanceFraction();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a25a0258eb0b928fc2eabdc0b4a07f064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetSaturation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of saturations (<em>sat</em>) as calculated by the reaction module. Reactions will change the volume of solution in a cell. The transport code must decide whether to ignore or account for this change in solution volume due to reactions. Following reactions, the cell saturation is calculated as solution volume (<a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a>) divided by the product of representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>) and the porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>). The cell saturation returned by <em>GetSaturation</em> may be less than or greater than the saturation set by the transport code (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and may be greater than or less than 1.0, even in fully saturated simulations. Only the following databases distributed with PhreeqcRM have molar volume information needed to accurately calculate solution volume and saturation: phreeqc.dat, Amm.dat, and pitzer.dat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sat</td><td>Vector to receive the saturations. Dimension of the array is set to <em>nxyz</em>, where <em>nxyz</em> is the number of user grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Values for inactive cells are set to 1e30.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> sat;
status = phreeqc_rm.GetSaturation(sat);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6179a2e85f8d5ac45174c097ac585dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetSelectedOutput </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>so</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the array of selected-output values for the current selected-output definition. <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> specifies which of the selected-output definitions is returned to the vector (<em>so</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">so</td><td>A vector to contain the selected-output values. Size of the vector is set to <em>col</em> times <em>nxyz</em>, where <em>col</em> is the number of columns in the selected-output definition (<a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>), and <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  // Process results here
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af386ce0d85cd88eaf13ef75d8f891901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSelectedOutputColumnCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of columns in the current selected-output definition. <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> specifies which of the selected-output definitions is used. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of columns in the current selected-output definition, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  // Print results
  for (int i = 0; i < phreeqc_rm.GetSelectedOutputRowCount()/2; i++)
  {
    std::vector<std::string> headings;
    headings.resize(col);
    std::cerr << "     Selected output: " << "\n";
    for (int j = 0; j < col; j++)
    {
      status = phreeqc_rm.GetSelectedOutputHeading(j, headings[j]);
      std::cerr << "          " << j << " " << headings[j] << ": " << so[j*nxyz + i] << "\n";
    }
  }
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="ad31d2f31f4b64d01fdd0c0cddb471d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSelectedOutputCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of selected-output definitions. <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> specifies which of the selected-output definitions is used. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of selected-output definitions, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  // Process results here
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dfd1de7f3b7511b1a789e2f0f1ed897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetSelectedOutputHeading </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>heading</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a selected-output heading. The number of headings is determined by <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>. <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a> specifies which of the selected-output definitions is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">icol</td><td>The sequence number of the heading to be retrieved, 0 based. </td></tr>
    <tr><td class="paramname">heading</td><td>A string to receive the heading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  std::vector<std::string> headings;
  headings.resize(col);
  std::cerr << "     Selected output: " << "\n";
  for (int j = 0; j < col; j++)
  {
    status = phreeqc_rm.GetSelectedOutputHeading(j, headings[j]);
    std::cerr << "          " << j << " " << headings[j] << "\n";
  }
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b4de1533d505faf5b5b3f913d9c6246"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GetSelectedOutputOn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current value of the selected-output property. A value of true for this property indicates that selected output data will be requested this time step. A value of false indicates that selected output will not be retrieved for this time step; processing the selected output is avoided with some time savings. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td><em>True</em>, selected output will be requested; <em>false</em>, selected output will not be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
bool so_on = phreeqc_rm.GetSelectedOutputOn();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a6534199611b9dc7d7dc15e33da58fb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSelectedOutputRowCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of rows in the current selected-output definition. However, the method is included only for convenience; the number of rows is always equal to the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of rows in the current selected-output definition, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a093a4d3c160ef5aa7cd65cf29b084268">SetCurrentSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::vector<double> so;
  int col = phreeqc_rm.GetSelectedOutputColumnCount();
  status = phreeqc_rm.GetSelectedOutput(so);
  // Print results
  for (int i = 0; i < phreeqc_rm.GetSelectedOutputRowCount()/2; i++)
  {
    std::vector<std::string> headings;
    headings.resize(col);
    std::cerr << "     Selected output: " << "\n";
    for (int j = 0; j < col; j++)
    {
      status = phreeqc_rm.GetSelectedOutputHeading(j, headings[j]);
      std::cerr << "          " << j << " " << headings[j] << ": " << so[j*nxyz + i] << "\n";
    }
  }
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf5f318493ca94de71fbf839910f379"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetSICount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of phases in the initial-phreeqc module for which saturation indices could be calculated. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a7bf5f318493ca94de71fbf839910f379">GetSICount</a>. This method may be useful when generating selected output definitions related to saturation indices.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of phases in the initial-phreeqc module for which saturation indices could be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a9f47533d63d2df6972acbbfef7d5e037">GetSINames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<std::string> &si = phreeqc_rm.GetSINames();
for (size_t i = 0; i < phreeqc_rm.GetSICount(); i++)
{
oss << "    " << si[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f47533d63d2df6972acbbfef7d5e037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSINames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of the names of all phases for which saturation indices (SIs) could be calculated. The list includes all phases that contain only elements included in the components in the initial-phreeqc module. The list assumes that all components are present to be able to calculate the entire list of SIs; it may be that one or more components are missing in any specific cell. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a9f47533d63d2df6972acbbfef7d5e037">GetSINames</a>. This method may be useful when generating selected output definitions related to saturation indices.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique phase name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a7bf5f318493ca94de71fbf839910f379">GetSICount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -saturation_indices " << "\n";
// molalities of aqueous species
const std::vector<std::string> &si = phreeqc_rm.GetSINames();
for (size_t i = 0; i < phreeqc_rm.GetSICount(); i++)
{
oss << "    " << si[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="afbdf4e16dd8c17839ea4e26ad2e0711b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSolidSolutionComponents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of solid solution components. The list of solid solution components includes all components in any SOLID_SOLUTION definitions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#afbdf4e16dd8c17839ea4e26ad2e0711b">GetSolidSolutionComponents</a>. This method may be useful when generating selected output definitions related to solid solutions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique solid solution component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aa69ecfcf73c2ca674b4a02377bc58e1f">GetSolidSolutionComponentsCount</a>, <a class="el" href="class_phreeqc_r_m.html#a20f694b09fa03c7c120d5333ee05d4f8">GetSolidSolutionNames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -solid_solutions " << "\n";
// solid solutions
const std::vector<std::string> &ss_comps = phreeqc_rm.GetSolidSolutionComponents();
const std::vector<std::string> &ss_names = phreeqc_rm.GetSolidSolutionNames();
for (size_t i = 0; i < phreeqc_rm.GetSolidSolutionComponentsCount(); i++)
{

oss << "    ";
oss.width(15);
oss  << std::left << ss_comps[i];
oss << " # " << ss_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="aa69ecfcf73c2ca674b4a02377bc58e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetSolidSolutionComponentsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of solid solution components in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#aa69ecfcf73c2ca674b4a02377bc58e1f">GetSolidSolutionComponentsCount</a>. This method may be useful when generating selected output definitions related to solid solutions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of solid solution components in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#afbdf4e16dd8c17839ea4e26ad2e0711b">GetSolidSolutionComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a20f694b09fa03c7c120d5333ee05d4f8">GetSolidSolutionNames</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -solid_solutions " << "\n";
// solid solutions
const std::vector<std::string> &ss_comps = phreeqc_rm.GetSolidSolutionComponents();
const std::vector<std::string> &ss_names = phreeqc_rm.GetSolidSolutionNames();
for (size_t i = 0; i < phreeqc_rm.GetSolidSolutionComponentsCount(); i++)
{

oss << "    ";
oss.width(15);
oss  << std::left << ss_comps[i];
oss << " # " << ss_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a20f694b09fa03c7c120d5333ee05d4f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSolidSolutionNames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of solid solution names that correspond with the solid solution components. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a20f694b09fa03c7c120d5333ee05d4f8">GetSolidSolutionNames</a>. The solid solution names vector is the same length as the solid solution components vector and provides the corresponding name of solid solution containing the component. This method may be useful when generating selected output definitions related to solid solutions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a solid solution name corresponding to the solid solution components vector; a solid solution name may occur multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aa69ecfcf73c2ca674b4a02377bc58e1f">GetSolidSolutionComponentsCount</a>, <a class="el" href="class_phreeqc_r_m.html#afbdf4e16dd8c17839ea4e26ad2e0711b">GetSolidSolutionComponents</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
oss << "  -solid_solutions " << "\n";
// solid solutions
const std::vector<std::string> &ss_comps = phreeqc_rm.GetSolidSolutionComponents();
const std::vector<std::string> &ss_names = phreeqc_rm.GetSolidSolutionNames();
for (size_t i = 0; i < phreeqc_rm.GetSolidSolutionComponentsCount(); i++)
{

oss << "    ";
oss.width(15);
oss  << std::left << ss_comps[i];
oss << " # " << ss_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="ae98170e44d8269da4bde0c42f2ab4e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; GetSolutionVolume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector reference to the current solution volumes as calculated by the reaction module. Dimension of the vector will be <em>nxyz</em>, where <em>nxyz</em> is the number of user grid cells. Values for inactive cells are set to 1e30. Only the following databases distributed with PhreeqcRM have molar volume information needed to accurately calculate solution volume: phreeqc.dat, Amm.dat, and pitzer.dat. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>reference to current solution volumes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.RunCells();
const std::vector<double> &volume = phreeqc_rm.GetSolutionVolume();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aef1f8e12c41d225c06226d07ba181486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetSpeciesConcentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>species_conc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector reference to aqueous species concentrations (<em>species_conc</em>). This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The list of aqueous species is determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> and includes all aqueous species that can be made from the set of components. Solution volumes used to calculate mol/L are calculated by the reaction module. Only the following databases distributed with PhreeqcRM have molar volume information needed to accurately calculate solution volume: phreeqc.dat, Amm.dat, and pitzer.dat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species_conc</td><td>Vector to receive the aqueous species concentrations. Dimension of the vector is set to <em>nspecies</em> times <em>nxyz</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>), and <em>nxyz</em> is the number of grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Concentrations are moles per liter. Values for inactive cells are set to 1e30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
status = phreeqc_rm.RunCells();
std::vector<double> c;
status = phreeqc_rm.GetSpeciesConcentrations(c);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a997ef74307edc3107819375525e7b286"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetSpeciesCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of aqueous species used in the reaction module. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The list of aqueous species is determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> and includes all aqueous species that can be made from the set of components. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>The number of aqueous species. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aed8af1412943fa2f99968827cf53ab42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; GetSpeciesD25 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector reference to diffusion coefficients at 25C for the set of aqueous species. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. Diffusion coefficients are defined in SOLUTION_SPECIES data blocks, normally in the database file. Databases distributed with the reaction module that have diffusion coefficients defined are phreeqc.dat, Amm.dat, and pitzer.dat. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>reference to the diffusion coefficients at 25 C, m^2/s. Dimension of the vector is <em>nspecies</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
const std::vector < double > & species_d = phreeqc_rm.GetSpeciesD25();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a46e62ada4632f1fe2f75205cdcf8df60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> GetSpeciesLog10Gammas </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>species_log10gammas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector reference to log10 aqueous species activity coefficients (<em>species_log10gammas</em>). This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The list of aqueous species is determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> and includes all aqueous species that can be made from the set of components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species_log10gammas</td><td>Vector to receive the log10 aqueous species activity coefficients. Dimension of the vector is set to <em>nspecies</em> times <em>nxyz</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>), and <em>nxyz</em> is the number of grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Values for inactive cells are set to 1e30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
status = phreeqc_rm.RunCells();
std::vector<double> species_gammas;
status = phreeqc_rm.GetSpeciesLog10Gammas(species_gammas);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="adcdbece4a9759d711ef68684f9d895ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSpeciesNames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector reference to the names of the aqueous species. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The list of aqueous species is determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> and includes all aqueous species that can be made from the set of components. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">names</td><td>Vector of strings containing the names of the aqueous species. Dimension of the vector is <em>nspecies</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
const std::vector<std::string> &species = phreeqc_rm.GetSpeciesNames();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aaef7ac666c8bf48409d17d898f6a9041"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GetSpeciesSaveOn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the species-save property. By default, concentrations of aqueous species are not saved. Setting the species-save property to true allows aqueous species concentrations to be retrieved with <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, and solution compositions to be set with <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">True</td><td>indicates solution species concentrations are saved and can be used for multicomponent-diffusion calculations; <em>False</em> indicates that solution species concentrations are not saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd>
<dd>
<a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
bool species_on = phreeqc_rm.GetSpeciesSaveOn();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aa85cfc68368c1ec30a6318397dd57daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cxxNameDouble&gt;&amp; GetSpeciesStoichiometry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector reference to the stoichiometry of each aqueous species. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>of cxxNameDouble instances (maps) that contain the component names and associated stoichiometric coefficients for each aqueous species. Dimension of the vector is <em>nspecies</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<std::string> &species = phreeqc_rm.GetSpeciesNames();
const std::vector < double > & species_z = phreeqc_rm.GetSpeciesZ();
const std::vector < double > & species_d = phreeqc_rm.GetSpeciesD25();
bool species_on = phreeqc_rm.GetSpeciesSaveOn();
int nspecies = phreeqc_rm.GetSpeciesCount();
for (int i = 0; i < nspecies; i++)
{
  std::ostringstream strm;
  strm << species[i] << "\n";
  strm << "    Charge: " << species_z[i] << std::endl;
  strm << "    Dw:     " << species_d[i] << std::endl;
  cxxNameDouble::const_iterator it = phreeqc_rm.GetSpeciesStoichiometry()[i].begin();
  for (; it != phreeqc_rm.GetSpeciesStoichiometry()[i].end(); it++)
  {
    strm << "          " << it->first << "   " << it->second << "\n";
  }
  phreeqc_rm.OutputMessage(strm.str());
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a2003caaa23e9039372b774ea98e874cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; GetSpeciesZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector reference to the charge on each aqueous species. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>containing the charge on each aqueous species. Dimension of the vector is <em>nspecies</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int npecies = phreeqc_rm.GetSpeciesCount();
const std::vector < double > & species_z = phreeqc_rm.GetSpeciesZ();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aab7b8935b7c6837a172503950e1f1e92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int&gt;&amp; GetStartCell </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of integers that contains the smallest reaction-cell number assigned to each worker. Each worker is assigned a range of reaction-cell numbers that are run during a call to <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>. The range of reaction cell numbers for a worker may vary as load rebalancing occurs. At any point in the calculations, the first cell and last cell to be run by a worker can be found in the vectors returned by <em>GetStartCell</em> and <a class="el" href="class_phreeqc_r_m.html#acc4ef701a669817c88287cfe2a24fe21">GetEndCell</a>. Each method returns a vector of integers that has size of the number of threads (<a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>), if using OPENMP, or the number of processes (<a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>), if using MPI. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>Vector of integers, one for each worker, that gives the first reaction cell to be run by each worker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#acc4ef701a669817c88287cfe2a24fe21">GetEndCell</a>, <a class="el" href="class_phreeqc_r_m.html#aed9b321354b98cfde021c1dbcdd1a321">GetThreadCount</a>, <a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>, <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Current distribution of cells for workers\n";
oss << "Worker First Cell   Last Cell\n";
int n;
n = phreeqc_rm.GetThreadCount() * phreeqc_rm.GetMpiTasks();
for (int i = 0; i < n; i++)
{
    oss << i << "      "
        << phreeqc_rm.GetStartCell()[i]
        << "            "
        << phreeqc_rm.GetEndCell()[i] << "\n";
}
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c336bc613c4794a5a5ded1adb2cd7ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSurfaceNames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of surface names (such as "Hfo") that correspond with the surface species names. The vectors referenced by <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a> and <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a> are the same length. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a>. This method may be useful when generating selected output definitions related to surfaces.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a surface name corresponding to the surface species vector; a surface name may occur multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of surface species
const std::vector<std::string> &surf_species = phreeqc_rm.GetSurfaceSpecies();
const std::vector<std::string> &surf_types = phreeqc_rm.GetSurfaceTypes();
const std::vector<std::string> &surf_names = phreeqc_rm.GetSurfaceNames();
for (size_t i = 0; i < phreeqc_rm.GetSurfaceSpeciesCount(); i++)
{
oss << "    ";
oss.width(15);
oss << std::left << surf_species[i];
oss << " # ";
oss.width(15);
oss << surf_types[i] << "   " << surf_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="ae082dbed24f997b815194cb03d0d407c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSurfaceSpecies </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of surface species names (such as "Hfo_wOH"). The list of surface species is derived from the list of components (<a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>) and the list of all surface site types (such as "Hfo_w") that are included in SURFACE definitions in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a>. This method may be useful when generating selected output definitions related to surfaces.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a unique surface species name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a>, <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of surface species
const std::vector<std::string> &surf_species = phreeqc_rm.GetSurfaceSpecies();
const std::vector<std::string> &surf_types = phreeqc_rm.GetSurfaceTypes();
const std::vector<std::string> &surf_names = phreeqc_rm.GetSurfaceNames();
for (size_t i = 0; i < phreeqc_rm.GetSurfaceSpeciesCount(); i++)
{
oss << "    ";
oss.width(15);
oss << std::left << surf_species[i];
oss << " # ";
oss.width(15);
oss << surf_types[i] << "   " << surf_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2466626f87a4756601db252bb25337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetSurfaceSpeciesCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of surface species (such as "Hfo_wOH") in the initial-phreeqc module. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a>. This method may be useful when generating selected output definitions related to surfaces.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of surface species in the initial-phreeqc module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a>, <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of surface species
const std::vector<std::string> &surf_species = phreeqc_rm.GetSurfaceSpecies();
const std::vector<std::string> &surf_types = phreeqc_rm.GetSurfaceTypes();
const std::vector<std::string> &surf_names = phreeqc_rm.GetSurfaceNames();
for (size_t i = 0; i < phreeqc_rm.GetSurfaceSpeciesCount(); i++)
{
oss << "    ";
oss.width(15);
oss << std::left << surf_species[i];
oss << " # ";
oss.width(15);
oss << surf_types[i] << "   " << surf_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b114af9c932a1eafcd16a2e60b3cb9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; GetSurfaceTypes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of surface site types (such as "Hfo_w") that correspond with the surface species names. The vectors referenced by <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a> and <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a> are the same length. <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> must be called before <a class="el" href="class_phreeqc_r_m.html#a5b114af9c932a1eafcd16a2e60b3cb9a">GetSurfaceTypes</a>. This method may be useful when generating selected output definitions related to surfaces.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">const</td><td>std::vector&lt;std::string&gt;&amp; A vector of strings; each string is a surface site type for the corresponding species in the surface species vector; a surface site type may occur multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a2c2466626f87a4756601db252bb25337">GetSurfaceSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#ae082dbed24f997b815194cb03d0d407c">GetSurfaceSpecies</a>, <a class="el" href="class_phreeqc_r_m.html#a7c336bc613c4794a5a5ded1adb2cd7ee">GetSurfaceNames</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
// molalities of surface species
const std::vector<std::string> &surf_species = phreeqc_rm.GetSurfaceSpecies();
const std::vector<std::string> &surf_types = phreeqc_rm.GetSurfaceTypes();
const std::vector<std::string> &surf_names = phreeqc_rm.GetSurfaceNames();
for (size_t i = 0; i < phreeqc_rm.GetSurfaceSpeciesCount(); i++)
{
oss << "    ";
oss.width(15);
oss << std::left << surf_species[i];
oss << " # ";
oss.width(15);
oss << surf_types[i] << "   " << surf_names[i] << "\n";
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a296b63a1e849bd0b56189deca5b434a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; GetTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vector reference to the current temperatures of the cells. By default, the temperature vector is initialized to 25 C; if <a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a> has not been called, worker solutions will have temperatures as defined in input files (<a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a>) or input strings (<a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>); if <a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a> has been called, worker solutions will have the temperatures as defined by <a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>of temperatures, in degrees C. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>, <a class="el" href="class_phreeqc_r_m.html#af783c5401d3f2758fb65e0fb88fd9ffe">GetPressure</a>, <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector<double> &  tempc = phreeqc_rm.GetTemperature();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="aed9b321354b98cfde021c1dbcdd1a321"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetThreadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of threads, which is equal to the number of workers used to run in parallel with OPENMP. For the OPENMP version, the number of threads is set implicitly or explicitly with the constructor (<a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>). For the MPI version, the number of threads is always one for each process. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of threads used for OPENMP parallel processing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a767aba1bbc547eec71cb0067854b8a9e">GetMpiTasks</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Number of threads: " << phreeqc_rm.GetThreadCount() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers; result is always 1. </dd></dl>

</div>
</div>
<a class="anchor" id="aeee6230be86953d7bbf32319dcbed8fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GetTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current simulation time in seconds. The reaction module does not change the time value, so the returned value is equal to the default (0.0) or the last time set by <a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>current simulation time, in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a7b64a9231c9758dd5c38074de0bebeb7">GetTimeConversion</a>, <a class="el" href="class_phreeqc_r_m.html#ab8df589c2719c9f8070bdf547398602f">GetTimeStep</a>, <a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>, <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream strm;
strm << "Beginning transport calculation "
     << phreeqc_rm.GetTime() * phreeqc_rm.GetTimeConversion()
     << " days\n";
phreeqc_rm.LogMessage(strm.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b64a9231c9758dd5c38074de0bebeb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GetTimeConversion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a multiplier to convert time from seconds to another unit, as specified by the user. The reaction module uses seconds as the time unit. The user can set a conversion factor (<a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>) and retrieve it with GetTimeConversion. The reaction module only uses the conversion factor when printing the long version of cell chemistry (<a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>), which is rare. Default conversion factor is 1.0. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Multiplier</td><td>to convert seconds to another time unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aeee6230be86953d7bbf32319dcbed8fb">GetTime</a>, <a class="el" href="class_phreeqc_r_m.html#ab8df589c2719c9f8070bdf547398602f">GetTimeStep</a>, <a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>, <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream strm;
strm << "Beginning transport calculation "
     <<   phreeqc_rm.GetTime() * phreeqc_rm.GetTimeConversion()
     << " days\n";
phreeqc_rm.LogMessage(strm.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8df589c2719c9f8070bdf547398602f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GetTimeStep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current simulation time step in seconds. This is the time over which kinetic reactions are integrated in a call to <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>. The reaction module does not change the time-step value, so the returned value is equal to the default (0.0) or the last time step set by <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>current simulation time step, in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aeee6230be86953d7bbf32319dcbed8fb">GetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a7b64a9231c9758dd5c38074de0bebeb7">GetTimeConversion</a>, <a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>, <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream strm;
strm << "Time step "
     << phreeqc_rm.GetTimeStep() * phreeqc_rm.GetTimeConversion()
     << " days\n";
phreeqc_rm.LogMessage(strm.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a79c88809873ff087a08029b3f70ee440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsExchange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for exchangers. In PHREEQC input, exchangers are defined by moles of exchange sites (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#a493bd0929d290210735ee6e7d3e313c9">SetUnitsExchange</a> specifies how the number of moles of exchange sites in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for exchangers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a493bd0929d290210735ee6e7d3e313c9">SetUnitsExchange</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_exchange = phreeqc_rm.GetUnitsExchange();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a94f6a5b5ef016fe3d39da5803db15c2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsGasPhase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for gas phases. In PHREEQC input, gas phases are defined by moles of component gases (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#acb91663bccb79a4bd44c2cea4e4bae2f">SetUnitsGasPhase</a> specifies how the number of moles of component gases in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for gas phases (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#acb91663bccb79a4bd44c2cea4e4bae2f">SetUnitsGasPhase</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_gas_phase = phreeqc_rm.GetUnitsGasPhase();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a459b3b7e889175cd6921bee0a6925c56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsKinetics </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for kinetic reactants. In PHREEQC input, kinetics are defined by moles of kinetic reactants (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#a62278fa7e20047a358dcad3dffa7b6ba">SetUnitsKinetics</a> specifies how the number of moles of kinetic reactants in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for kinetic reactants (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a62278fa7e20047a358dcad3dffa7b6ba">SetUnitsKinetics</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_kinetics = phreeqc_rm.GetUnitsKinetics();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a85e5cc05ee11681e3e94d8e97f6e6665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsPPassemblage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for pure phase assemblages (equilibrium phases). In PHREEQC input, equilibrium phases are defined by moles of each phase (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#a553f501e1e26008b85e169123ad458a5">SetUnitsPPassemblage</a> specifies how the number of moles of phases in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for equilibrium phases (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a553f501e1e26008b85e169123ad458a5">SetUnitsPPassemblage</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_pp_assemblage = phreeqc_rm.GetUnitsPPassemblage();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a988e89c81bcaf299b19f419ae30d02d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsSolution </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the units of concentration used by the transport model. Options are 1, mg/L; 2 mol/L; or 3, mass fraction, kg/kgs. In PHREEQC, solutions are defined by the number of moles of each element in the solution. The units of transport concentration are used when transport concentrations are converted to solution moles by <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a> and <a class="el" href="class_phreeqc_r_m.html#af91d035f4839205de54a34a0d62cf9e8">Concentrations2Utility</a>. The units of solution concentration also are used when solution moles are converted to transport concentrations by <a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>. <br />
<br />
To convert from mg/L to moles of element in the representative volume of a reaction cell, mg/L is converted to mol/L and multiplied by the solution volume, which is the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). To convert from mol/L to moles of element in a cell, mol/L is multiplied by the solution volume. To convert from mass fraction to moles of element in a cell, kg/kgs is converted to mol/kgs, multiplied by density (<a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>) and multiplied by the solution volume. <br />
<br />
To convert from moles of element in the representative volume of a reaction cell to mg/L, the number of moles of an element is divided by the solution volume resulting in mol/L, and then converted to mg/L. To convert from moles of element in the representative volume of a reaction cell to mol/L, the number of moles of an element is divided by the solution volume resulting in mol/L. To convert from moles of element in the representative volume of a reaction cell to mass fraction, the number of moles of an element is converted to kg and divided by the total mass of the solution. Two options are available for the volume and mass of solution that are used in converting to transport concentrations: (1) the volume and mass of solution are calculated by PHREEQC, or (2) the volume of solution is the product of porosity, saturation, and representative volume, and the mass of solution is volume times density as defined by <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>. Which option is used is determined by <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Units</td><td>for concentrations in transport. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af91d035f4839205de54a34a0d62cf9e8">Concentrations2Utility</a>, <a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>, <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_solution = phreeqc_rm.GetUnitsSolution();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aee53757d11bc48cddcde12ee2c72f8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsSSassemblage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for solid-solution assemblages. In PHREEQC input, solid solutions are defined by moles of each component (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#a579b445479212a6f9dc3455ecdb40a20">SetUnitsSSassemblage</a> specifies how the number of moles in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for solid solutions (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a579b445479212a6f9dc3455ecdb40a20">SetUnitsSSassemblage</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_ss_exchange = phreeqc_rm.GetUnitsSSassemblage();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c0b7e64493556c8e844e7c6f3a0a227"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetUnitsSurface </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the input units for surfaces. In PHREEQC input, surfaces are defined by moles of surface sites (<em>Mp</em>). <a class="el" href="class_phreeqc_r_m.html#a0578f4b12f58165e57381ceddffba8d9">SetUnitsSurface</a> specifies how the number of moles of surface sites in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Input</td><td>units for solid surfaces (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a0578f4b12f58165e57381ceddffba8d9">SetUnitsSurface</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int units_surface = phreeqc_rm.GetUnitsSurface();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc2f010956bab031ecb51024ac82687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;IPhreeqcPhast *&gt;&amp; GetWorkers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the vector of IPhreeqcPhast instances. IPhreeqcPhast inherits from IPhreeqc, and the vector can be interpreted as a vector of pointers to the worker, InitialPhreeqc, and Utility IPhreeqc instances. For OPENMP, there are <em>nthreads</em> workers, where <em>nthreads</em> is defined in the constructor (<a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>). For MPI, there is a single worker. For OPENMP and MPI, there is one InitialPhreeqc and one Utility instance. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Vector</td><td>of IPhreeqcPhast instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#adf01f0b9ab2101d9b073c205804b255e">PhreeqcRM::PhreeqcRM</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
const std::vector < IPhreeqcPhast *> & w = phreeqc_rm.GetWorkers();
w[0]->AccumulateLine("Delete; -all");
int iphreeqc_result = w[0]->RunAccumulated();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="aef9e308a4cb39cc3a29cfdebd5db263d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2Concentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector (<em>destination_c</em>) with concentrations from solutions in the InitialPhreeqc instance. The method is used to obtain concentrations for boundary conditions. If a negative value is used for a cell in <em>boundary_solution1</em>, then the highest numbered solution in the InitialPhreeqc instance will be used for that cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_c</td><td>Vector to receive the concentrations.The dimension of <em>destination_c</em> is set to <em>ncomps</em> times <em>n_boundary</em>, where <em>ncomps</em> is the number of components returned from <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> or <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>, and <em>n_boundary</em> is the dimension of the vector <em>boundary_solution1</em>. </td></tr>
    <tr><td class="paramname">boundary_solution1</td><td>Vector of solution index numbers that refer to solutions in the InitialPhreeqc instance. Size is <em>n_boundary</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> bc_conc;
std::vector<int> bc1;
int nbound = 1;
bc1.resize(nbound, 0);                      // solution 0 from InitialIPhreeqc instance
status = phreeqc_rm.InitialPhreeqc2Concentrations(bc_conc, bc1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8d8b4470a9d6b6c9e41a5e87d971f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2Concentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fraction1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector (<em>destination_c</em>) with concentrations from solutions in the InitialPhreeqc instance. The method is used to obtain concentrations for boundary conditions that are mixtures of solutions. If a negative value is used for a cell in <em>boundary_solution1</em>, then the highest numbered solution in the InitialPhreeqc instance will be used for that cell. Concentrations may be a mixture of two solutions, <em>boundary_solution1</em> and <em>boundary_solution2</em>, with a mixing fraction for <em>boundary_solution1</em> of <em>fraction1</em> and mixing fraction for <em>boundary_solution2</em> of (1 - <em>fraction1</em>). A negative value for <em>boundary_solution2</em> implies no mixing, and the associated value for <em>fraction1</em> is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_c</td><td>Vector of concentrations extracted from the InitialPhreeqc instance. The dimension of <em>destination_c</em> is set to <em>ncomps</em> times <em>n_boundary</em>, where <em>ncomps</em> is the number of components returned from <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> or <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>, and <em>n_boundary</em> is the dimension of the vectors <em>boundary_solution1</em>, <em>boundary_solution2</em>, and <em>fraction1</em>. </td></tr>
    <tr><td class="paramname">boundary_solution1</td><td>Vector of solution index numbers that refer to solutions in the InitialPhreeqc instance. Size is <em>n_boundary</em>. </td></tr>
    <tr><td class="paramname">boundary_solution2</td><td>Vector of solution index numbers that that refer to solutions in the InitialPhreeqc instance and are defined to mix with <em>boundary_solution1</em>. Size is <em>n_boundary</em>. </td></tr>
    <tr><td class="paramname">fraction1</td><td>Fraction of boundary_solution1 that mixes with (1 - <em>fraction1</em>) of <em>boundary_solution2</em>. Size is <em>n_boundary</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> bc_conc, bc_f1;
std::vector<int> bc1, bc2;
int nbound = 1;
bc1.resize(nbound, 0);                      // solution 0 from InitialIPhreeqc instance
bc2.resize(nbound, 1);                      // solution 1 from InitialIPhreeqc instance
bc_f1.resize(nbound, 0.4);                  // mixing fraction for bc1, result is 0.4/0.6 mix
status = phreeqc_rm.InitialPhreeqc2Concentrations(bc_conc, bc1, bc2, bc_f1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="acd8534dbf786f708df79065e3329defc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2Module </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_conditions1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer solutions and reactants from the InitialPhreeqc instance to the reaction-module workers. <em>Initial_conditions1</em> is used to select initial conditions, including solutions and reactants, for each cell of the model, without mixing. <em>Initial_conditions1</em> is dimensioned 7 times <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). The dimension of 7 refers to solutions and reactants in the following order: (0) SOLUTIONS, (1) EQUILIBRIUM_PHASES, (2) EXCHANGE, (3) SURFACE, (4) GAS_PHASE, (5) SOLID_SOLUTIONS, and (6) KINETICS. The definition initial_solution1[3*nxyz + 99] = 2, indicates that cell 99 (0 based) contains the SURFACE definition (index 3) defined by SURFACE 2 in the InitialPhreeqc instance (created in the InitialPhreeqc instance either by <a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a> or <a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_conditions1</td><td>Vector of solution and reactant index numbers that refer to definitions in the InitialPhreeqc instance. Size is 7 times <em>nxyz</em>. The order of definitions is given above. Negative values are ignored, resulting in no definition of that entity for that cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<int> ic1;
ic1.resize(nxyz*7, -1);
for (int i = 0; i < nxyz; i++)
{
  ic1[i] = 1;              // Solution 1
  ic1[nxyz + i] = -1;      // Equilibrium phases none
  ic1[2*nxyz + i] = 1;     // Exchange 1
  ic1[3*nxyz + i] = -1;    // Surface none
  ic1[4*nxyz + i] = -1;    // Gas phase none
  ic1[5*nxyz + i] = -1;    // Solid solutions none
  ic1[6*nxyz + i] = -1;    // Kinetics none
}
status = phreeqc_rm.InitialPhreeqc2Module(ic1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a51a995bd031543a11c745a19af12fcbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2Module </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_conditions1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_conditions2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fraction1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer solutions and reactants from the InitialPhreeqc instance to the reaction-module workers, possibly with mixing. In its simplest form, <em>initial_conditions1</em> is used to select initial conditions, including solutions and reactants, for each cell of the model, without mixing. <em>Initial_conditions1</em> is dimensioned 7 times <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). The dimension of 7 refers to solutions and reactants in the following order: (0) SOLUTIONS, (1) EQUILIBRIUM_PHASES, (2) EXCHANGE, (3) SURFACE, (4) GAS_PHASE, (5) SOLID_SOLUTIONS, and (6) KINETICS. The definition initial_solution1[3*nxyz + 99] = 2, indicates that cell 99 (0 based) contains the SURFACE definition (index 3) defined by SURFACE 2 in the InitialPhreeqc instance (either by <a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a> or <a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>). <br />
<br />
It is also possible to mix solutions and reactants to obtain the initial conditions for cells. For mixing, <em>initials_conditions2</em> contains numbers for a second entity that mixes with the entity defined in <em>initial_conditions1</em>. <em>Fraction1</em> contains the mixing fraction for <em>initial_conditions1</em>, whereas (1 - <em>fraction1</em>) is the mixing fraction for <em>initial_conditions2</em>. The definitions initial_solution1[3*nxyz + 99] = 2, initial_solution2[3*nxyz + 99] = 3, fraction1[3*nxyz + 99] = 0.25 indicates that cell 99 (0 based) contains a mixture of 0.25 SURFACE 2 and 0.75 SURFACE 3, where the surface compositions have been defined in the InitialPhreeqc instance. If the user number in <em>initial_conditions2</em> is negative, no mixing occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_conditions1</td><td>Vector of solution and reactant index numbers that refer to definitions in the InitialPhreeqc instance. Size is 7 times <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). The order of definitions is given above. Negative values are ignored, resulting in no definition of that entity for that cell. </td></tr>
    <tr><td class="paramname">initial_conditions2</td><td>Vector of solution and reactant index numbers that refer to definitions in the InitialPhreeqc instance. Nonnegative values of <em>initial_conditions2</em> result in mixing with the entities defined in <em>initial_conditions1</em>. Negative values result in no mixing. Size is 7 times <em>nxyz</em>. The order of definitions is given above. </td></tr>
    <tr><td class="paramname">fraction1</td><td>Fraction of <em>initial_conditions1</em> that mixes with (1 - <em>fraction1</em>) of <em>initial_conditions2</em>. Size is 7 times <em>nxyz</em>. The order of definitions is given above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<int> ic1, ic2;
ic1.resize(nxyz*7, -1);
ic2.resize(nxyz*7, -1);
std::vector<double> f1;
f1.resize(nxyz*7, 1.0);
for (int i = 0; i < nxyz; i++)
{
  ic1[i] = 1;              // Solution 1
  ic1[nxyz + i] = -1;      // Equilibrium phases none
  ic1[2*nxyz + i] = 1;     // Exchange 1
  ic1[3*nxyz + i] = -1;    // Surface none
  ic1[4*nxyz + i] = -1;    // Gas phase none
  ic1[5*nxyz + i] = -1;    // Solid solutions none
  ic1[6*nxyz + i] = -1;    // Kinetics none
}
status = phreeqc_rm.InitialPhreeqc2Module(ic1, ic2, f1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4300a3ba8987c8093d8ca88835667a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2SpeciesConcentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector <em>destination_c</em> with aqueous species concentrations from solutions in the InitialPhreeqc instance. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The method is used to obtain aqueous species concentrations for boundary conditions. If a negative value is used for a cell in <em>boundary_solution1</em>, then the highest numbered solution in the InitialPhreeqc instance will be used for that cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_c</td><td>Vector of aqueous concentrations extracted from the InitialPhreeqc instance. The dimension of <em>species_c</em> is <em>nspecies</em> times <em>n_boundary</em>, where <em>nspecies</em> is the number of aqueous species returned from <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, and <em>n_boundary</em> is the dimension of <em>boundary_solution1</em>. </td></tr>
    <tr><td class="paramname">boundary_solution1</td><td>Vector of solution index numbers that refer to solutions in the InitialPhreeqc instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> bc_conc, bc_f1;
std::vector<int> bc1, bc2;
int nbound = 1;
bc1.resize(nbound, 0);                      // solution 0 from Initial IPhreeqc instance
status = phreeqc_rm.InitialPhreeqc2SpeciesConcentrations(bc_conc, bc1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="adbb319053abc6a7be2f93f4801866027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqc2SpeciesConcentrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_solution2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fraction1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector <em>destination_c</em> with aqueous species concentrations from solutions in the InitialPhreeqc instance. This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The method is used to obtain aqueous species concentrations for boundary conditions. If a negative value is used for a cell in <em>boundary_solution1</em>, then the highest numbered solution in the InitialPhreeqc instance will be used for that cell. Concentrations may be a mixture of two solutions, <em>boundary_solution1</em> and <em>boundary_solution2</em>, with a mixing fraction for <em>boundary_solution1</em> of <em>fraction1</em> and mixing fraction for <em>boundary_solution2</em> of (1 - <em>fraction1</em>). A negative value for <em>boundary_solution2</em> implies no mixing, and the associated value for <em>fraction1</em> is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_c</td><td>Vector of aqueous concentrations extracted from the InitialPhreeqc instance. The dimension of <em>species_c</em> is <em>nspecies</em> times <em>n_boundary</em>, where <em>nspecies</em> is the number of aqueous species returned from <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, and <em>n_boundary</em> is the dimension of <em>boundary_solution1</em>. </td></tr>
    <tr><td class="paramname">boundary_solution1</td><td>Vector of solution index numbers that refer to solutions in the InitialPhreeqc instance. </td></tr>
    <tr><td class="paramname">boundary_solution2</td><td>Vector of solution index numbers that refer to solutions in the InitialPhreeqc instance and are defined to mix with <em>boundary_solution1</em>. Size is same as <em>boundary_solution1</em>. </td></tr>
    <tr><td class="paramname">fraction1</td><td>Vector of fractions of <em>boundary_solution1</em> that mix with (1 - <em>fraction1</em>) of <em>boundary_solution2</em>. Size is same as <em>boundary_solution1</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> bc_conc, bc_f1;
std::vector<int> bc1, bc2;
int nbound = 1;
bc1.resize(nbound, 0);                      // solution 0 from Initial IPhreeqc instance
bc2.resize(nbound, -1);                     // no bc2 solution for mixing
bc_f1.resize(nbound, 1.0);                  // mixing fraction for bc1
status = phreeqc_rm.InitialPhreeqc2SpeciesConcentrations(bc_conc, bc1, bc2, bc_f1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="adf8c258616d470bde73c490bd97ccf4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> InitialPhreeqcCell2Module </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_numbers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cell numbered <em>n</em> in the InitialPhreeqc instance is selected to populate a series of transport cells. All reactants with the number <em>n</em> are transferred along with the solution. If MIX <em>n</em> exists, it is used for the definition of the solution. If <em>n</em> is negative, <em>n</em> is redefined to be the largest solution or MIX number in the InitialPhreeqc instance. All reactants for each cell in the list <em>cell_numbers</em> are removed before the cell definition is copied from the InitialPhreeqc instance to the workers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number that refers to a solution or MIX and associated reactants in the InitialPhreeqc instance. </td></tr>
    <tr><td class="paramname">cell_numbers</td><td>A vector of grid-cell numbers (user's grid-cell numbering system) that will be populated with cell <em>n</em> from the InitialPhreeqc instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<int> module_cells;
module_cells.push_back(18);
module_cells.push_back(19);
status = phreeqc_rm.InitialPhreeqcCell2Module(-1, module_cells);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a471917c3a3b72d32a3aff2277c846ce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> LoadDatabase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>database</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a database for all IPhreeqc instances&ndash;workers, InitialPhreeqc, and Utility. All definitions of the reaction module are cleared (SOLUTION_SPECIES, PHASES, SOLUTIONs, etc.), and the database is read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">database</td><td>String containing the database name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.LoadDatabase("phreeqc.dat");
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aefb0eec0cbbd282137f9e699fc7136ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LogMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a message to the log file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a380cc59e9ee851d0493f6ee795b4c205">OutputMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream strm;
strm << "Beginning transport calculation " <<   phreeqc_rm.GetTime() * phreeqc_rm.GetTimeConversion() << " days\n";
strm << "          Time step             " <<   phreeqc_rm.GetTimeStep() * phreeqc_rm.GetTimeConversion() << " days\n";
phreeqc_rm.LogMessage(strm.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7bc27edb51d5c1b01042bc445a8950c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MpiAbort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI only. Calls MPI_Abort, which aborts MPI, and makes the reaction module unusable. Should be used only on encountering an unrecoverable error. </p><dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
int status = phreeqc_rm.MPI_Abort();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root or workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a386912253775a48a7c27c653f85ae867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> MpiWorker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI only. Nonroot processes (processes with <a class="el" href="class_phreeqc_r_m.html#a5b6435a77f5409c10ebfd8c70cb6a309">GetMpiMyself</a> &gt; 0) must call MpiWorker to be able to respond to messages from the root to accept data, perform calculations, and (or) return data within the reaction module. MpiWorker contains a loop that reads a message from root, performs a task, and waits for another message from root. <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>, and <a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a> are examples of methods that send a message from root to get the workers to perform a task. The workers will respond to all methods that are designated "workers must be in the loop of MpiWorker" in the MPI section of the method documentation. The workers will continue to respond to messages from root until root calls <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a>. <br />
<br />
(Advanced) The list of tasks that the workers perform can be extended by using <a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a>. It is then possible to use the MPI processes to perform other developer-defined tasks, such as transport calculations, without exiting from the MpiWorker loop. Alternatively, root calls <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a> to allow the workers to continue past a call to MpiWorker. The workers perform developer-defined calculations, and then MpiWorker is called again to respond to requests from root to perform reaction-module tasks.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). MpiWorker returns a value only when <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a> is called by root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a>, <a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a>, <a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
PhreeqcRM phreeqc_rm(nxyz, MPI_COMM_WORLD);
int mpi_myself;
if (MPI_Comm_rank(MPI_COMM_WORLD, &mpi_myself) != MPI_SUCCESS)
{
  exit(4);
}
if (mpi_myself > 0)
{
  phreeqc_rm.MpiWorker();
  return EXIT_SUCCESS;
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by all workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a480f76aef4f930795c95ee93c6da51a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> MpiWorkerBreak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI only. This method is called by root to force nonroot processes (processes with <a class="el" href="class_phreeqc_r_m.html#a5b6435a77f5409c10ebfd8c70cb6a309">GetMpiMyself</a> &gt; 0) to return from a call to <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> contains a loop that reads a message from root, performs a task, and waits for another message from root. The workers respond to all methods that are designated "workers must be in the loop of MpiWorker" in the MPI section of the method documentation. The workers will continue to respond to messages from root until root calls MpiWorkerBreak. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>, <a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a>, <a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a> (C only). </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.MpiWorkerBreak();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a64697f92b2323655ae7593fe2a35cb19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> OpenFiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the output and log files. Files are named prefix.chem.txt and prefix.log.txt based on the prefix defined by <a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ae7054027113b3f4128b2f02fa07fafac">SetFilePrefix</a>, <a class="el" href="class_phreeqc_r_m.html#a097034fe3815caf183fb2635a8559c91">GetFilePrefix</a>, <a class="el" href="class_phreeqc_r_m.html#abf9eb39e299d0d44388367dd27900996">CloseFiles</a>, <a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>, <a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a380cc59e9ee851d0493f6ee795b4c205">OutputMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetFilePrefix("Advect_cpp");
phreeqc_rm.OpenFiles();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a380cc59e9ee851d0493f6ee795b4c205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a message to the output file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>, <a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream oss;
oss << "Database:                                         " << phreeqc_rm.GetDatabaseFileName().c_str() << "\n";
oss << "Number of threads:                                " << phreeqc_rm.GetThreadCount() << "\n";
oss << "Number of MPI processes:                          " << phreeqc_rm.GetMpiTasks() << "\n";
oss << "MPI task number:                                  " << phreeqc_rm.GetMpiMyself() << "\n";
oss << "File prefix:                                      " << phreeqc_rm.GetFilePrefix() << "\n";
oss << "Number of grid cells in the user's model:         " << phreeqc_rm.GetGridCellCount() << "\n";
oss << "Number of chemistry cells in the reaction module: " << phreeqc_rm.GetChemistryCellCount() << "\n";
oss << "Number of components for transport:               " << phreeqc_rm.GetComponentCount() << "\n";
oss << "Error handler mode:                               " << phreeqc_rm.GetErrorHandlerMode() << "\n";
phreeqc_rm.OutputMessage(oss.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a36deedf92cfa74f46317e8cbd8843ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> ReturnHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>e_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process an IRM_RESULT return code. If the return code is nonnegative, no action is taken. If the return code is negative, the return code is decoded and printed as an error message along with the second argument (std::string). On an error, the method will return the same return code, throw an exception, or exit the program depending on the setting for <a class="el" href="class_phreeqc_r_m.html#a06c01d10280887c3ace8e0fbe179baa2">SetErrorHandlerMode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Return code to be processed. </td></tr>
    <tr><td class="paramname">e_string</td><td>Error message to be printed in case of an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>The first argument to the method is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a06c01d10280887c3ace8e0fbe179baa2">SetErrorHandlerMode</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.ReturnHandler(irm_result, "Previous method failed.");
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root or workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0b3bf039921645f512d447d3fc6b34b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> RunCells </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a reaction step for all reaction cells in the reaction module. Normally, tranport concentrations are transferred to the reaction cells (<a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>) before reaction calculations are run. The length of time over which kinetic reactions are integrated is set by <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. Other properties that may need to be updated as a result of the transport calculations include porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), temperature (<a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>), and pressure (<a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>, <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSelectedOutputOn(print_selected_output_on);
status = phreeqc_rm.SetPrintChemistryOn(print_chemistry_on, false, false);
status = phreeqc_rm.SetPorosity(por);             // If porosity changes
status = phreeqc_rm.SetSaturation(sat);           // If saturation changes
status = phreeqc_rm.SetTemperature(temperature);  // If temperature changes
status = phreeqc_rm.SetPressure(pressure);        // If pressure changes
status = phreeqc_rm.SetConcentrations(c);         // Transported concentrations
status = phreeqc_rm.SetTimeStep(time_step);       // Time step for kinetic reactions
time = time + time_step;
status = phreeqc_rm.SetTime(time);
status = phreeqc_rm.RunCells();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f1310be884080f16ff62597ae56455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> RunFile </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_phreeqc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utility</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chemistry_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a PHREEQC input file. The first three arguments determine which IPhreeqc instances will run the file&ndash;the workers, the InitialPhreeqc instance, and (or) the Utility instance. Input files that modify the thermodynamic database should be run by all three sets of instances. Files with SELECTED_OUTPUT definitions that will be used during the time-stepping loop need to be run by the workers. Files that contain initial conditions or boundary conditions should be run by the InitialPhreeqc instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workers</td><td><em>True</em>, the workers will run the file; <em>False</em>, the workers will not run the file. </td></tr>
    <tr><td class="paramname">initial_phreeqc</td><td><em>True</em>, the InitialPhreeqc instance will run the file; <em>False</em>, the InitialPhreeqc will not run the file. </td></tr>
    <tr><td class="paramname">utility</td><td><em>True</em>, the Utility instance will run the file; <em>False</em>, the Utility instance will not run the file. </td></tr>
    <tr><td class="paramname">chemistry_name</td><td>Name of the file to run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.RunFile(true, true, true, "advect.pqi");
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e4b46db5b1b600a6f8ce4522a27d955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> RunString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_phreeqc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utility</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a PHREEQC input string. The first three arguments determine which IPhreeqc instances will run the string&ndash;the workers, the InitialPhreeqc instance, and (or) the Utility instance. Input strings that modify the thermodynamic database should be run by all three sets of instances. Strings with SELECTED_OUTPUT definitions that will be used during the time-stepping loop need to be run by the workers. Strings that contain initial conditions or boundary conditions should be run by the InitialPhreeqc instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workers</td><td><em>True</em>, the workers will run the string; <em>False</em>, the workers will not run the string. </td></tr>
    <tr><td class="paramname">initial_phreeqc</td><td><em>True</em>, the InitialPhreeqc instance will run the string; <em>False</em>, the InitialPhreeqc will not run the string. </td></tr>
    <tr><td class="paramname">utility</td><td><em>True</em>, the Utility instance will run the string; <em>False</em>, the Utility instance will not run the string. </td></tr>
    <tr><td class="paramname">input_string</td><td>String containing PHREEQC input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::string input = "DELETE; -all";
status = phreeqc_rm.RunString(true, false, true, input.c_str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0462b92c2a5aa473af73ba3a54cd27e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScreenMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print message to the screen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>, <a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a380cc59e9ee851d0493f6ee795b4c205">OutputMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a9a3e996c5dd4c3a11c6cf63aec9923c7">WarningMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::ostringstream strm;
strm << "Beginning transport calculation "
     <<   phreeqc_rm.GetTime() * phreeqc_rm.GetTimeConversion()
     << " days\n";
strm << "          Time step             "
     <<   phreeqc_rm.GetTimeStep() * phreeqc_rm.GetTimeConversion()
     << " days\n";
phreeqc_rm.ScreenMessage(strm.str());
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="ad61e9d1d88b23b5da1dad1eb35e415b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetComponentH2O </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select whether to include H2O in the component list. The concentrations of H and O must be known accurately (8 to 10 significant digits) for the numerical method of PHREEQC to produce accurate pH and pe values. Because most of the H and O are in the water species, it may be more robust (require less accuracy in transport) to transport the excess H and O (the H and O not in water) and water. The default setting (<em>true</em>) is to include water, excess H, and excess O as components. A setting of <em>false</em> will include total H and total O as components. SetComponentH2O must be called before <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em> (default), excess H, excess O, and water are included in the component list; <em>False</em>, total H and O are included in the component list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetComponentH2O(true);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c61949ecec49665d4c6ae2ccd040159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetConcentrations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the vector of concentrations (<em>c</em>) to set the moles of components in each reaction cell. The volume of water in a cell is the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and reference volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). The moles of each component are determined by the volume of water and per liter concentrations. If concentration units (<a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>) are mass fraction, the density (as specified by <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>) is used to convert from mass fraction to per mass per liter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Vector of component concentrations. Size of vector is <em>ncomps</em> times <em>nxyz</em>, where <em>ncomps</em> is the number of components as determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> or <a class="el" href="class_phreeqc_r_m.html#a25ac2b0172e9aa11f3537c74d4e1aa7b">GetComponentCount</a> and <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> c;
c.resize(nxyz * components.size());
...
AdvectCpp(c, bc_conc, ncomps, nxyz, nbound);
status = phreeqc_rm.SetPorosity(por);             // If porosity changes
status = phreeqc_rm.SetSaturation(sat);           // If saturation changes
status = phreeqc_rm.SetTemperature(temperature);  // If temperature changes
status = phreeqc_rm.SetPressure(pressure);        // If pressure changes
status = phreeqc_rm.SetConcentrations(c);         // Transported concentrations
status = phreeqc_rm.SetTimeStep(time_step);       // Time step for kinetic reactions
time = time + time_step;
status = phreeqc_rm.SetTime(time);
status = phreeqc_rm.RunCells();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a093a4d3c160ef5aa7cd65cf29b084268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetCurrentSelectedOutputUserNumber </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the current selected output by user number. The user may define multiple SELECTED_OUTPUT data blocks for the workers. A user number is specified for each data block. The value of the argument <em>n_user</em> selects which of the SELECTED_OUTPUT definitions will be used for selected-output operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_user</td><td>User number of the SELECTED_OUTPUT data block that is to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af7eb8523bff2a58b0ba1c3835f5ffb92">GetNthSelectedOutputUserNumber</a>, <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#af386ce0d85cd88eaf13ef75d8f891901">GetSelectedOutputColumnCount</a>, <a class="el" href="class_phreeqc_r_m.html#ad31d2f31f4b64d01fdd0c0cddb471d16">GetSelectedOutputCount</a>, <a class="el" href="class_phreeqc_r_m.html#a6534199611b9dc7d7dc15e33da58fb7d">GetSelectedOutputRowCount</a>, <a class="el" href="class_phreeqc_r_m.html#a8dfd1de7f3b7511b1a789e2f0f1ed897">GetSelectedOutputHeading</a>, <a class="el" href="class_phreeqc_r_m.html#a8321dd429fbfa0c7b84754aae63d8d88">SetSelectedOutputOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
for (int isel = 0; isel < phreeqc_rm.GetSelectedOutputCount(); isel++)
{
  int n_user = phreeqc_rm.GetNthSelectedOutputUserNumber(isel);
  status = phreeqc_rm.SetCurrentSelectedOutputUserNumber(n_user);
  std::cerr << "Selected output sequence number: " << isel << "\n";
  std::cerr << "Selected output user number:     " << n_user << "\n";
  std::vector<double> so;
  status = phreeqc_rm.GetSelectedOutput(so);
  // Process results here
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="abc453d9dbfef8223bb289900ac5d404d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetDensity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>density</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the density for each reaction cell. These density values are used when converting from transported mass-fraction concentrations (<a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>) to produce per liter concentrations during a call to <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>. They are also used when converting from reaction-cell concentrations to transport concentrations (<a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>), if <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a> is set to <em>false</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>Vector of densities. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>, <a class="el" href="class_phreeqc_r_m.html#a7c61949ecec49665d4c6ae2ccd040159">SetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a3b22ee262f00a1186c4455098315ba07">SetUnitsSolution</a>, <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> initial_density;
initial_density.resize(nxyz, 1.0);
phreeqc_rm.SetDensity(initial_density);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d70b6e7cf9071181291bdcab7603a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetDumpFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dump_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the name of the dump file. It is the name used by <a class="el" href="class_phreeqc_r_m.html#a69bc339ef18879fc6747c7cb3ee8b407">DumpModule</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dump_name</td><td>Name of dump file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a69bc339ef18879fc6747c7cb3ee8b407">DumpModule</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetDumpFileName("advection_cpp.dmp");
bool dump_on = true;
bool append = false;
status = phreeqc_rm.DumpModule(dump_on, append);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a06c01d10280887c3ace8e0fbe179baa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetErrorHandlerMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the action to be taken when the reaction module encounters an error. Options are 0, return to calling program with an error return code (default); 1, throw an exception, in C++, the exception can be caught, for C and Fortran, the program will exit; or 2, attempt to exit gracefully. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Error handling mode: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
PhreeqcRM phreeqc_rm(nxyz, nthreads);
IRM_RESULT status;
status = phreeqc_rm.SetErrorHandlerMode(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7054027113b3f4128b2f02fa07fafac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetFilePrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the prefix for the output (prefix.chem.txt) and log (prefix.log.txt) files. These files are opened by <a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix used when opening the output and log files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#abf9eb39e299d0d44388367dd27900996">CloseFiles</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetFilePrefix("Advect_cpp");
phreeqc_rm.OpenFiles();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a82f0bf250a5b462cb5d88b49cd98f5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetMpiWorkerCallbackC </td>
          <td>(</td>
          <td class="paramtype">int(*)(int *method, void *cookie)&#160;</td>
          <td class="paramname"><em>fcn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI and C/C++ only. Defines a callback function that allows additional tasks to be done by the workers. The method <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> contains a loop, where the workers receive a message (an integer), run a function corresponding to that integer, and then wait for another message. SetMpiWorkerCallbackC allows C or C++ developers to add another function that responds to additional integer messages by calling developer-defined functions corresponding to those integers. <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> calls the callback function when the message number is not one of the PhreeqcRM message numbers. Messages are unique integer numbers. PhreeqcRM uses integers in a range beginning at 0. It is suggested that developers use message numbers starting at 1000 or higher for their tasks. The callback function calls a developer-defined function specified by the message number and then returns to <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> to wait for another message. <br />
<br />
In C and C++, an additional pointer can be supplied to find the data necessary to do the task. A void pointer may be set with <a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a>. This pointer is passed to the callback function through a void pointer argument in addition to the integer message argument. The pointer may be to a struct or class instance that provides a number of additional pointers to data. <a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a> must be called by each worker before <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> is called. <br />
<br />
The motivation for this method is to allow the workers to perform other tasks, for instance, parallel transport calculations, within the structure of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. The callback function can be used to allow the workers to receive data, perform transport calculations, and (or) send results, without leaving the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. Alternatively, it is possible for the workers to return from <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a> by a call to <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a> by root. The workers could then call subroutines to receive data, calculate transport, and send data, and then resume processing PhreeqcRM messages from root with another call to <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcn</td><td>A function that returns an integer and has an integer argument and a void * argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>, <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a>, <a class="el" href="class_phreeqc_r_m.html#ad92c97628615d7209259522662860a7b">SetMpiWorkerCallbackCookie</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
Code executed by root:
// root calls a function that will involve the workers
int istatus = do_something(&comm);

Code executed by workers:
phreeqc_rm.SetMpiWorkerCallbackC(worker_tasks_cc);
phreeqc_rm.SetMpiWorkerCallbackCookie(&comm);
phreeqc_rm.MpiWorker();

Code executed by root and workers:
int do_something(void *cookie)
{
    int method_number = 1000;
    MP_TYPE *comm = (MP_TYPE *) cookie;
    int mpi_tasks, mpi_myself, worker_number;
    MPI_Comm_size(MPI_COMM_WORLD, &mpi_tasks);
    MPI_Comm_rank(MPI_COMM_WORLD, &mpi_myself);
    std::stringstream msg;
    if (mpi_myself == 0)
    {
        MPI_Bcast(&method_number, 1, MPI_INT, 0, *comm);
        fprintf(stderr, "I am root.\n");
        for (int i = 1; i < mpi_tasks; i++)
        {
            MPI_Status status;
            MPI_Recv(&worker_number, 1, MPI_INT, i, 0, MPI_COMM_WORLD, &status);
            fprintf(stderr, "Recieved data from worker number %d.\n", worker_number);
        }
    }
    else
    {
        MPI_Send(&mpi_myself, 1, MPI_INT, 0, 0, *comm);
    }
    return 0;
}

Code called by workers from method MpiWorker:
int worker_tasks_cc(int *task_number, void * cookie)
{
    if (*task_number == 1000)
    {
        do_something(cookie);
    }
    return 0;
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by workers, before call to <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad92c97628615d7209259522662860a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetMpiWorkerCallbackCookie </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI and C/C++ only. Defines a void pointer that can be used by C and C++ functions called from the callback function (<a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a>) to locate data for a task. The C callback function that is registered with <a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a> has two arguments, an integer message to identify a task, and a void pointer. SetMpiWorkerCallbackCookie sets the value of the void pointer that is passed to the callback function. The void pointer may be a pointer to a struct of class instance that contains additonal pointers to data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>Void pointer that can be used by subroutines called from the callback function to locate data needed to perform a task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>, <a class="el" href="class_phreeqc_r_m.html#a480f76aef4f930795c95ee93c6da51a0">MpiWorkerBreak</a>, <a class="el" href="class_phreeqc_r_m.html#a82f0bf250a5b462cb5d88b49cd98f5cc">SetMpiWorkerCallbackC</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
Code executed by root:
// root calls a function that will involve the workers
int istatus = do_something(&comm);

Code executed by workers:
phreeqc_rm.SetMpiWorkerCallbackC(worker_tasks_cc);
phreeqc_rm.SetMpiWorkerCallbackCookie(&comm);
phreeqc_rm.MpiWorker();

Code executed by root and workers:
int do_something(void *cookie)
{
    int method_number = 1000;
    MP_TYPE *comm = (MP_TYPE *) cookie;
    int mpi_tasks, mpi_myself, worker_number;
    MPI_Comm_size(MPI_COMM_WORLD, &mpi_tasks);
    MPI_Comm_rank(MPI_COMM_WORLD, &mpi_myself);
    std::stringstream msg;
    if (mpi_myself == 0)
    {
        MPI_Bcast(&method_number, 1, MPI_INT, 0, *comm);
        fprintf(stderr, "I am root.\n");
        for (int i = 1; i < mpi_tasks; i++)
        {
            MPI_Status status;
            MPI_Recv(&worker_number, 1, MPI_INT, i, 0, MPI_COMM_WORLD, &status);
            fprintf(stderr, "Recieved data from worker number %d.\n", worker_number);
        }
    }
    else
    {
        MPI_Send(&mpi_myself, 1, MPI_INT, 0, 0, *comm);
    }
    return 0;
}

Code called by workers from method MpiWorker:
int worker_tasks_cc(int *task_number, void * cookie)
{
    if (*task_number == 1000)
    {
        do_something(cookie);
    }
    return 0;
}
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by workers, before call to <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a60735d2ea38e0a31fb3cc05684881a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetMpiWorkerCallbackFortran </td>
          <td>(</td>
          <td class="paramtype">int(*)(int *method)&#160;</td>
          <td class="paramname"><em>fcn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPI and Fortran only. Defines a callback function that allows additional tasks to be done by the workers. See documentation of PhreeqcRM for Fortran, method SetMpiWorkerCallback. </p>

</div>
</div>
<a class="anchor" id="a999cacdcaddc4b9c20b7a00ee7ea9f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetPartitionUZSolids </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the property for partitioning solids between the saturated and unsaturated parts of a partially saturated cell.</p>
<p>The option is intended to be used by saturated-only flow codes that allow a variable water table. The value has meaning only when saturations less than 1.0 are encountered. The partially saturated cells may have a small water-to-rock ratio that causes reactions to proceed differently relative to fully saturated cells. By setting <em>SetPartitionUZSolids</em> to true, the amounts of solids and gases are partioned according to the saturation. If a cell has a saturation of 0.5, then the water interacts with only half of the solids and gases; the other half is unreactive until the water table rises. As the saturation in a cell varies, solids and gases are transferred between the saturated and unsaturated (unreactive) reservoirs of the cell. Unsaturated-zone flow and transport codes will probably use the default (false), which assumes all gases and solids are reactive regardless of saturation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em>, the fraction of solids and gases available for reaction is equal to the saturation; <em>False</em> (default), all solids and gases are reactive regardless of saturation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a730bd52b5380331c67d47960bb096f00">GetPartitionUZSolids</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
phreeqc_rm.SetPartitionUZSolids(false);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aabe5d536517af8694debc756b504f4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetPorosity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>por</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the porosity for each reaction cell. The volume of water in a reaction cell is the product of porosity, saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">por</td><td>Vector of porosities, unitless. Default is 0.1. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> por;
por.resize(nxyz, 0.2);
status = phreeqc_rm.SetPorosity(por);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9baced65c80a9466af317faaab9ad7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetPressure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the pressure for each reaction cell. Pressure effects are considered only in three of the databases distributed with PhreeqcRM: phreeqc.dat, Amm.dat, and pitzer.dat. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Vector of pressures, in atm. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a725b62c3f80f6be11ba952b92b315441">SetTemperature</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> pressure;
pressure.resize(nxyz, 2.0);
phreeqc_rm.SetPressure(pressure);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b4b2dff739ed070378aa8a3584a5399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetPrintChemistryMask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable detailed output for each reaction cell. Printing for a reaction cell will occur only when the printing is enabled with <a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a> and the <em>cell_mask</em> value is 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_mask</td><td>Vector of integers. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). A value of 0 will disable printing detailed output for the cell; a value of 1 will enable printing detailed output for a cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<int> print_chemistry_mask;
print_chemistry_mask.resize(nxyz, 0);
for (int i = 0; i < nxyz/2; i++)
{
  print_chemistry_mask[i] = 1;
}
status = phreeqc_rm.SetPrintChemistryMask(print_chemistry_mask);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad390b50790a370bba13b02318355b3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetPrintChemistryOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_phreeqc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set property that enables or disables printing detailed output from reaction calculations to the output file for a set of cells defined by <a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a>. The detailed output prints all of the output typical of a PHREEQC reaction calculation, which includes solution descriptions and the compositions of all other reactants. The output can be several hundred lines per cell, which can lead to a very large output file (prefix.chem.txt, <a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>). For the worker instances, the output can be limited to a set of cells (<a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a>) and, in general, the amount of information printed can be limited by use of options in the PRINT data block of PHREEQC (applied by using <a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a> or <a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>). Printing the detailed output for the workers is generally used only for debugging, and PhreeqcRM will run significantly faster when printing detailed output for the workers is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workers</td><td><em>True</em>, enable detailed printing in the worker instances; <em>False</em>, disable detailed printing in the worker instances. </td></tr>
    <tr><td class="paramname">initial_phreeqc</td><td><em>True</em>, enable detailed printing in the InitialPhreeqc instance; <em>False</em>, disable detailed printing in the InitialPhreeqc instance. </td></tr>
    <tr><td class="paramname">utility</td><td><em>True</em>, enable detailed printing in the Utility instance; <em>False</em>, disable detailed printing in the Utility instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#aa1f1310be884080f16ff62597ae56455">RunFile</a>, <a class="el" href="class_phreeqc_r_m.html#a1e4b46db5b1b600a6f8ce4522a27d955">RunString</a>, <a class="el" href="class_phreeqc_r_m.html#a4b4b2dff739ed070378aa8a3584a5399">SetPrintChemistryMask</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetPrintChemistryOn(false, true, false);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a41f2b742b0e4b9d8ba180202ca9ee438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetRebalanceByCell </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the load-balancing algorithm. PhreeqcRM attempts to rebalance the load of each thread or process such that each thread or process takes the same amount of time to run its part of a <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> calculation. Two algorithms are available; one uses individual times for each cell and accounts for cells that were not run because saturation was zero (default), and the other assigns an average time to all cells. The methods are similar, but limited testing indicates the default method performs better. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em>, indicates individual cell times are used in rebalancing (default); <em>False</em>, indicates average times are used in rebalancing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a136d9ac45da1ab013f5d9f7236d55850">SetRebalanceFraction</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetRebalanceByCell(true);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a136d9ac45da1ab013f5d9f7236d55850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetRebalanceFraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the fraction of cells that are transferred among threads or processes when rebalancing. PhreeqcRM attempts to rebalance the load of each thread or process such that each thread or process takes the same amount of time to run its part of a <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> calculation. The rebalancing transfers cell calculations among threads or processes to try to achieve an optimum balance. <em>SetRebalanceFraction</em> adjusts the calculated optimum number of cell transfers by a fraction from 0 to 1.0 to determine the actual number of cell transfers. A value of zero eliminates load rebalancing. A value less than 1.0 is suggested to slow the approach to the optimum cell distribution and avoid possible oscillations when too many cells are transferred at one iteration, requiring reverse transfers at the next iteration. Default is 0.5.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Fraction from 0.0 to 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a41f2b742b0e4b9d8ba180202ca9ee438">SetRebalanceByCell</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetRebalanceFraction(0.5);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3738d57a411bdef1f08d3b8ec66e2f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetRepresentativeVolume </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the representative volume of each reaction cell. By default the representative volume of each reaction cell is 1 liter. The volume of water in a reaction cell is determined by the product of the representative volume, the porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), and the saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>). The numerical method of PHREEQC is more robust if the water volume for a reaction cell is within a couple orders of magnitude of 1.0. Small water volumes caused by small porosities and (or) small saturations (and (or) small representative volumes) may cause non-convergence of the numerical method. In these cases, a larger representative volume may help. Note that increasing the representative volume also increases the number of moles of the reactants in the reaction cell (minerals, surfaces, exchangers, and others), which are defined as moles per representative volume. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Vector of representative volumes, in liters. Default is 1.0 liter. Size of array is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> rv;
rv.resize(nxyz, 2.0);
status = phreeqc_rm.SetRepresentativeVolume(rv);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a191e1e4a66362bd2e1e5e6b26acfcc95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetSaturation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the saturation of each reaction cell. Saturation is a fraction ranging from 0 to 1. The volume of water in a cell is the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<em>SetSaturation</em>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). As a result of a reaction calculation, solution properties (density and volume) will change; the databases phreeqc.dat, Amm.dat, and pitzer.dat have the molar volume data to calculate these changes. The methods <a class="el" href="class_phreeqc_r_m.html#a1890077c451ea8864e441dbf4bd45a8d">GetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a>, and <a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a> can be used to account for these changes in the succeeding transport calculation. <em>SetRepresentativeVolume</em> should be called before initial conditions are defined for the reaction cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sat</td><td>Vector of saturations, unitless. Default 1.0. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a1890077c451ea8864e441dbf4bd45a8d">GetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#a25a0258eb0b928fc2eabdc0b4a07f064">GetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#ae98170e44d8269da4bde0c42f2ab4e75">GetSolutionVolume</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> sat;
sat.resize(nxyz, 1.0);
status = phreeqc_rm.SetSaturation(sat);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a9c25a7dd33870fb20efe9d7d367386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetScreenOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the property that controls whether messages are written to the screen. Messages include information about rebalancing during <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>, and any messages written with <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em>, enable screen messages; <em>False</em>, disable screen messages. Default is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>, <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetScreenOn(true);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root. </dd></dl>

</div>
</div>
<a class="anchor" id="a8321dd429fbfa0c7b84754aae63d8d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetSelectedOutputOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the property that controls whether selected-output results are available to be retrieved with <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>. <em>True</em> indicates that selected-output results will be accumulated during <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a> and can be retrieved with <a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>; <em>False</em> indicates that selected-output results will not be accumulated during <a class="el" href="class_phreeqc_r_m.html#ac0b3bf039921645f512d447d3fc6b34b">RunCells</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em>, enable selected output; <em>False</em>, disable selected output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a6179a2e85f8d5ac45174c097ac585dd0">GetSelectedOutput</a>, <a class="el" href="class_phreeqc_r_m.html#ad390b50790a370bba13b02318355b3a9">SetPrintChemistryOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSelectedOutputOn(true);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acf105c074d5735433178e941c7a609e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetSpeciesSaveOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of the species-save property. This method enables or disables use of PhreeqcRM with multicomponent-diffusion transport calculations. By default, concentrations of aqueous species are not saved. Setting the species-save property to <em>true</em> allows aqueous species concentrations to be retrieved with <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, and solution compositions to be set with <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. <em>SetSpeciesSaveOn</em> must be called before calls to <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">save_on</td><td><em>True</em> indicates species concentrations are saved; <em>False</em> indicates species concentrations are not saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#a35039947fade6a9f3e94fe0654ea5ae4">SpeciesConcentrations2Module</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a725b62c3f80f6be11ba952b92b315441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetTemperature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the temperature for each reaction cell. If <em>SetTemperature</em> is not called, worker solutions will have temperatures as defined by initial conditions (<a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a> and <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of temperatures, in degrees C. Size of vector is <em>nxyz</em>, where <em>nxyz</em> is the number of grid cells in the user's model (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#af783c5401d3f2758fb65e0fb88fd9ffe">GetPressure</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#a9baced65c80a9466af317faaab9ad7d6">SetPressure</a>, <a class="el" href="class_phreeqc_r_m.html#a296b63a1e849bd0b56189deca5b434a4">GetTemperature</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
std::vector<double> temperature;
temperature.resize(nxyz, 20.0);
phreeqc_rm.SetTemperature(temperature);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers. </dd></dl>

</div>
</div>
<a class="anchor" id="a81a058be326aa249c25316b0cbac05e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set current simulation time for the reaction module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Current simulation time, in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>, <a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
time += time_step;
status = phreeqc_rm.SetTime(time);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7abc26d7a64299d4fa1b879a00c364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetTimeConversion </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>conv_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a factor to convert from seconds to user time units. Factor times seconds produces user time units.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conv_factor</td><td>Factor to convert seconds to user time units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a261cac78c338a2ef92b2b548e2c017ce">SetTimeStep</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
double time_conversion = 1.0 / 86400;
status = phreeqc_rm.SetTimeConversion(time_conversion);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a261cac78c338a2ef92b2b548e2c017ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetTimeStep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set current time step for the reaction module. This is the length of time over which kinetic reactions are integrated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_step</td><td>Time step, in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a81a058be326aa249c25316b0cbac05e7">SetTime</a>, <a class="el" href="class_phreeqc_r_m.html#a5b7abc26d7a64299d4fa1b879a00c364">SetTimeConversion</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
time_step = 86400.;
status = phreeqc_rm.SetTimeStep(time_step);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a493bd0929d290210735ee6e7d3e313c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsExchange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets input units for exchangers. In PHREEQC input, exchangers are defined by moles of exchange sites (<em>Mp</em>). <em>SetUnitsExchange</em> specifies how the number of moles of exchange sites in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-P)*RV.</p>
<p>If a single EXCHANGE definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of exchangers will be the same regardless of porosity. For option 1, the number of moles of exchangers will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of exchangers will vary directly with rock volume and inversely with porosity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for exchangers: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a79c88809873ff087a08029b3f70ee440">GetUnitsExchange</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsExchange(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acb91663bccb79a4bd44c2cea4e4bae2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsGasPhase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set input units for gas phases. In PHREEQC input, gas phases are defined by moles of component gases (<em>Mp</em>). <em>SetUnitsGasPhase</em> specifies how the number of moles of component gases in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<p>If a single GAS_PHASE definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of a gas component will be the same regardless of porosity. For option 1, the number of moles of a gas component will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of a gas component will vary directly with rock volume and inversely with porosity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for gas phases: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a94f6a5b5ef016fe3d39da5803db15c2a">GetUnitsGasPhase</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsGasPhase(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a62278fa7e20047a358dcad3dffa7b6ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsKinetics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set input units for kinetic reactants.</p>
<p>In PHREEQC input, kinetics are defined by moles of kinetic reactants (<em>Mp</em>). <em>SetUnitsKinetics</em> specifies how the number of moles of kinetic reactants in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<p>If a single KINETICS definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of kinetic reactants will be the same regardless of porosity. For option 1, the number of moles of kinetic reactants will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of kinetic reactants will vary directly with rock volume and inversely with porosity.</p>
<p>Note that the volume of water in a cell in the reaction module is equal to the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), the saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>), which is usually less than 1 liter. It is important to write the RATES definitions for homogeneous (aqueous) kinetic reactions to account for the current volume of water, often by calculating the rate of reaction per liter of water and multiplying by the volume of water (Basic function SOLN_VOL).</p>
<p>Rates that depend on surface area of solids, are not dependent on the volume of water. However, it is important to get the correct surface area for the kinetic reaction. To scale the surface area with the number of moles, the specific area (m^2 per mole of reactant) can be defined as a parameter (KINETICS; -parm), which is multiplied by the number of moles of reactant (Basic function M) in RATES to obtain the surface area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for kinetic reactants: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a459b3b7e889175cd6921bee0a6925c56">GetUnitsKinetics</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsKinetics(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a553f501e1e26008b85e169123ad458a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsPPassemblage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set input units for pure phase assemblages (equilibrium phases). In PHREEQC input, equilibrium phases are defined by moles of each phase (<em>Mp</em>). <em>SetUnitsPPassemblage</em> specifies how the number of moles of phases in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-P)*RV.</p>
<p>If a single EQUILIBRIUM_PHASES definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of a mineral will be the same regardless of porosity. For option 1, the number of moles of a mineral will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of a mineral will vary directly with rock volume and inversely with porosity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for equilibrium phases: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a85e5cc05ee11681e3e94d8e97f6e6665">GetUnitsPPassemblage</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsPPassemblage(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b22ee262f00a1186c4455098315ba07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsSolution </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solution concentration units used by the transport model. Options are 1, mg/L; 2 mol/L; or 3, mass fraction, kg/kgs. PHREEQC defines solutions by the number of moles of each element in the solution.</p>
<p>To convert from mg/L to moles of element in the representative volume of a reaction cell, mg/L is converted to mol/L and multiplied by the solution volume, which is the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). To convert from mol/L to moles of element in the representative volume of a reaction cell, mol/L is multiplied by the solution volume. To convert from mass fraction to moles of element in the representative volume of a reaction cell, kg/kgs is converted to mol/kgs, multiplied by density (<a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>) and multiplied by the solution volume.</p>
<p>To convert from moles of element in the representative volume of a reaction cell to mg/L, the number of moles of an element is divided by the solution volume resulting in mol/L, and then converted to mg/L. To convert from moles of element in a cell to mol/L, the number of moles of an element is divided by the solution volume resulting in mol/L. To convert from moles of element in a cell to mass fraction, the number of moles of an element is converted to kg and divided by the total mass of the solution. Two options are available for the volume and mass of solution that are used in converting to transport concentrations: (1) the volume and mass of solution are calculated by PHREEQC, or (2) the volume of solution is the product of porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>), and the mass of solution is volume times density as defined by <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>. Which option is used is determined by <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for solutions: 1, 2, or 3, default is 1, mg/L. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#a8df19c6fe5d51d6e8e45c5bbf8ad0712">UseSolutionDensityVolume</a>.</dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsSolution(2);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a579b445479212a6f9dc3455ecdb40a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsSSassemblage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set input units for solid-solution assemblages. In PHREEQC, solid solutions are defined by moles of each component (<em>Mp</em>). <em>SetUnitsSSassemblage</em> specifies how the number of moles of solid-solution components in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-@ P)*RV.</p>
<p>If a single SOLID_SOLUTION definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of a solid-solution component will be the same regardless of porosity. For option 1, the number of moles of a solid-solution component will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of a solid-solution component will vary directly with rock volume and inversely with porosity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for solid solutions: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aee53757d11bc48cddcde12ee2c72f8b9">GetUnitsSSassemblage</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsSSassemblage(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0578f4b12f58165e57381ceddffba8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SetUnitsSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set input units for surfaces. In PHREEQC input, surfaces are defined by moles of surface sites (<em>Mp</em>). <em>SetUnitsSurface</em> specifies how the number of moles of surface sites in a reaction cell (<em>Mc</em>) is calculated from the input value (<em>Mp</em>).</p>
<p>Options are 0, <em>Mp</em> is mol/L of RV (default), <em>Mc</em> = <em>Mp*RV</em>, where RV is the representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>); 1, <em>Mp</em> is mol/L of water in the RV, <em>Mc</em> = <em>Mp*P*RV</em>, where <em>P</em> is porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>); or 2, <em>Mp</em> is mol/L of rock in the RV, <em>Mc</em> = <em>Mp*</em>(1-<em>P</em>)*RV.</p>
<p>If a single SURFACE definition is used for cells with different initial porosity, the three options scale quite differently. For option 0, the number of moles of surface sites will be the same regardless of porosity. For option 1, the number of moles of surface sites will be vary directly with porosity and inversely with rock volume. For option 2, the number of moles of surface sites will vary directly with rock volume and inversely with porosity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Units option for surfaces: 0, 1, or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a7c0b7e64493556c8e844e7c6f3a0a227">GetUnitsSurface</a>, <a class="el" href="class_phreeqc_r_m.html#acd8534dbf786f708df79065e3329defc">InitialPhreeqc2Module</a>, <a class="el" href="class_phreeqc_r_m.html#adf8c258616d470bde73c490bd97ccf4a">InitialPhreeqcCell2Module</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetUnitsSurface(1);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a35039947fade6a9f3e94fe0654ea5ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_irm_result_8h.html#aef83a7f869fdd6b83b5cd64db9bf0742">IRM_RESULT</a> SpeciesConcentrations2Module </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>species_conc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set solution concentrations in the reaction cells based on the vector of aqueous species concentrations (<em>species_conc</em>). This method is intended for use with multicomponent-diffusion transport calculations, and <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a> must be set to <em>true</em>. The list of aqueous species is determined by <a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a> and includes all aqueous species that can be made from the set of components. The method determines the total concentration of a component by summing the molarities of the individual species times the stoichiometric coefficient of the element in each species. Solution compositions in the reaction cells are updated with these component concentrations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">species_conc</td><td>Vector of aqueous species concentrations. Dimension of the array is <em>nspecies</em> times <em>nxyz</em>, where <em>nspecies</em> is the number of aqueous species (<a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>), and <em>nxyz</em> is the number of user grid cells (<a class="el" href="class_phreeqc_r_m.html#a3e0a9fa184dd8c8568b74cd5c10091c9">GetGridCellCount</a>). Concentrations are moles per liter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">IRM_RESULT</td><td>0 is success, negative is failure (See <a class="el" href="class_phreeqc_r_m.html#a0ac0574257be4e62ad314f61a1d9f015">DecodeError</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#ab292c626fe8a387d1144e139722ab43e">FindComponents</a>, <a class="el" href="class_phreeqc_r_m.html#aef1f8e12c41d225c06226d07ba181486">GetSpeciesConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#a997ef74307edc3107819375525e7b286">GetSpeciesCount</a>, <a class="el" href="class_phreeqc_r_m.html#aed8af1412943fa2f99968827cf53ab42">GetSpeciesD25</a>, <a class="el" href="class_phreeqc_r_m.html#a46e62ada4632f1fe2f75205cdcf8df60">GetSpeciesLog10Gammas</a>, <a class="el" href="class_phreeqc_r_m.html#adcdbece4a9759d711ef68684f9d895ad">GetSpeciesNames</a>, <a class="el" href="class_phreeqc_r_m.html#aaef7ac666c8bf48409d17d898f6a9041">GetSpeciesSaveOn</a>, <a class="el" href="class_phreeqc_r_m.html#aa85cfc68368c1ec30a6318397dd57daa">GetSpeciesStoichiometry</a>, <a class="el" href="class_phreeqc_r_m.html#a2003caaa23e9039372b774ea98e874cb">GetSpeciesZ</a>, <a class="el" href="class_phreeqc_r_m.html#acf105c074d5735433178e941c7a609e7">SetSpeciesSaveOn</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
status = phreeqc_rm.SetSpeciesSaveOn(true);
int ncomps = phreeqc_rm.FindComponents();
int nspecies = phreeqc_rm.GetSpeciesCount();
std::vector<double> c;
status = phreeqc_rm.GetSpeciesConcentrations(c);
...
SpeciesAdvectCpp(c, bc_conc, nspecies, nxyz, nbound);
status = phreeqc_rm.SpeciesConcentrations2Module(c);
status = phreeqc_rm.RunCells();
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8df19c6fe5d51d6e8e45c5bbf8ad0712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UseSolutionDensityVolume </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the volume and density to use when converting from the reaction-cell concentrations to transport concentrations (<a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>). Two options are available to convert concentration units: (1) the density and solution volume calculated by PHREEQC are used, or (2) the specified density (<a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>) and solution volume are determined by the product of saturation (<a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>), porosity (<a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>), and representative volume (<a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>). Transport models that consider density-dependent flow will probably use the PHREEQC-calculated density and solution volume (default), whereas transport models that assume constant-density flow will probably use specified values of density and solution volume. Only the following databases distributed with PhreeqcRM have molar-volume information needed to accurately calculate density and solution volume: phreeqc.dat, Amm.dat, and pitzer.dat. Density is only used when converting to or from transport units of mass fraction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><em>True</em> indicates that the solution density and volume as calculated by PHREEQC will be used to calculate concentrations. <em>False</em> indicates that the solution density set by <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a> and the volume determined by the product of <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, and <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, will be used to calculate concentrations retrieved by <a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#aa48d2ebd2e0efed5c49431c191159462">GetConcentrations</a>, <a class="el" href="class_phreeqc_r_m.html#abc453d9dbfef8223bb289900ac5d404d">SetDensity</a>, <a class="el" href="class_phreeqc_r_m.html#aabe5d536517af8694debc756b504f4bc">SetPorosity</a>, <a class="el" href="class_phreeqc_r_m.html#a3738d57a411bdef1f08d3b8ec66e2f3c">SetRepresentativeVolume</a>, <a class="el" href="class_phreeqc_r_m.html#a191e1e4a66362bd2e1e5e6b26acfcc95">SetSaturation</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
phreeqc_rm.UseSolutionDensityVolume(false);
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root, workers must be in the loop of <a class="el" href="class_phreeqc_r_m.html#a386912253775a48a7c27c653f85ae867">MpiWorker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3e996c5dd4c3a11c6cf63aec9923c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WarningMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>warnstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a warning message to the screen and the log file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warnstr</td><td>String to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_phreeqc_r_m.html#a64697f92b2323655ae7593fe2a35cb19">OpenFiles</a>, <a class="el" href="class_phreeqc_r_m.html#ad62514bca8a5119822e58a75db087cef">ErrorMessage</a>, <a class="el" href="class_phreeqc_r_m.html#aefb0eec0cbbd282137f9e699fc7136ab">LogMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a380cc59e9ee851d0493f6ee795b4c205">OutputMessage</a>, <a class="el" href="class_phreeqc_r_m.html#a0462b92c2a5aa473af73ba3a54cd27e7">ScreenMessage</a>. </dd></dl>
<dl class="section user"><dt>C++ Example:</dt><dd> 
<CODE>
<PRE>
phreeqc_rm.WarningMessage("Parameter is out of range, using default");
</PRE>
</CODE>
 </dd></dl>
<dl class="section user"><dt>MPI:</dt><dd>Called by root and (or) workers; only root writes to the log file. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_phreeqc_r_m_8h_source.html">PhreeqcRM.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 14 2019 12:27:57 for PhreeqcRM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
